/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.validation

import com.google.inject.Inject
import com.regnosys.rosetta.rosetta.RosettaCallableWithArgsCall
import com.regnosys.rosetta.rosetta.RosettaDataRule
import com.regnosys.rosetta.tests.RosettaInjectorProvider
import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*

@ExtendWith(InjectionExtension)
@InjectWith(RosettaInjectorProvider)
class RosettaValidatorTest implements RosettaIssueCodes {

	@Inject extension ValidationTestHelper
	@Inject extension ModelHelper
	
	@Test
	def void testLowerCaseClass() {
		val model =
		'''
			class partyIdentifier <"">
			{
				partyId string (1..1) <"">;
					[synonym FIX value PartyID tag 448]
					[synonym FpML value partyId]
			}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_CLASS, INVALID_CASE,
            "Class name should start with a capital")
	}
	
	@Test
	def void testLowerCaseEnumeration() {
		val model =
		'''
			enum quoteRejectReasonEnum <"">
				{
					UnknownSymbol,
					Other
				}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_ENUMERATION, INVALID_CASE,
            "Enumeration name should start with a capital")
	}
	
	@Test
	def void testUpperCaseAttribute() {
		val model =
		'''
			class PartyIdentifier <"">
				{
					PartyId string (1..1) <"">;
						[synonym FIX value PartyID tag 448]
						[synonym FpML value partyId]
				}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_REGULAR_ATTRIBUTE, INVALID_CASE,
            "Attribute name should start with a lower case")
	}
	
	@Test
	def void testLowerCaseDataRule() {
		val model = 
		'''
			data rule quote <"">
				when Foo exists
				then Bar exists
					
			class Foo{
			}
			
			class Bar{
			}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_DATA_RULE, INVALID_CASE,
			"Rule name should start with a capital")
	}
	
	@Test
	def void testLowerCaseProductQualifier() {
		val model = 
		'''
			isProduct bar
				EconomicTerms -> economic exists
					
			class EconomicTerms
			{
				economic string (1..1);
			}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_PRODUCT, INVALID_CASE,
			"Product qualifier name should start with a capital")
	}
	
	@Test
	def void testLowerCaseWorkflowRule() {
		val model = 
		'''
			workflow rule quote <"Bla">
				Foo precedes Bar
					
			class Foo{
			}
			
			class Bar{
			}
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_WORKFLOW_RULE, INVALID_CASE,
			"Workflow rule name should start with a capital")
	}
	
	@Test
	def void testInconsistentCommonAttributeType() {
		val model =
		'''
			class Foo {
				id int (1..1);
			}
			class Bar {
				id boolean (1..1);
			}
			
			workflow rule WorkflowRule
			Foo precedes Bar
			commonId id
		'''.parseRosetta
		model.assertError(ROSETTA_TREE_NODE, TYPE_ERROR, 
			"Attribute 'id' of class 'Bar' is of type 'boolean' (expected 'int')")
	}
	
	@Test
	def void testMissingCommonAttribute() {
		val model =
		'''
			class Foo {
				id int (1..1);
			}
			class Bar {
			}
			
			workflow rule
			WorkflowRule
			Foo precedes Bar
			commonId id
		'''.parseRosetta
		model.assertError(ROSETTA_TREE_NODE, MISSING_ATTRIBUTE, 
			"Class 'Bar' does not have an attribute")
	}
	
	@Test
	def void testTypeExpectation() {
		val model =
		'''
			class Foo {
				id int (1..1);
			}
			
			data rule R 
				when Foo -> id = True
				then Foo -> id < 1
		'''.parseRosetta
		val rule = model.elements.filter(RosettaDataRule).head
		rule.when.assertError(ROSETTA_DATA_RULE, TYPE_ERROR, 
			"Incompatible types: cannot use operator '=' with int and boolean.")
	}
	
	@Test
	def void testTypeExpectationMagicType() {
		'''
			qualifiedType productType {}
			class Foo {
				id productType (1..1);
				val int (1..1);
			}
			
			data rule R 
				when Foo -> id = "Type"
				then Foo -> val < 1
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void testTypeExpectationNoError() {
		val model =
		'''
			class Foo {
				id int (1..1);
			}
			
			data rule R
				when Foo -> id = 1
				then Foo -> id < 1
		'''.parseRosettaWithNoErrors
		val rule = model.elements.filter(RosettaDataRule).head
		rule.assertNoError(TYPE_ERROR)
	}
	
	@Test
	def void testTypeExpectationError() {
		val model =
		'''
			class Foo {
				id boolean (1..1);
			}
			
			data rule R 
				when Foo -> id = True
				then Foo -> id < 1
		'''.parseRosetta
		val rule = model.elements.filter(RosettaDataRule).head
		rule.when.assertError(ROSETTA_DATA_RULE, TYPE_ERROR, "Incompatible types: cannot use operator '<' with boolean and int.")
	}
	
	@Test
	def void testDuplicateAttribute() {
		val model = '''
			class Foo {
				i int (1..1);
			}
			
			class Bar extends Foo {
				i int (1..1);
			}
		'''.parseRosetta
		model.assertError(ROSETTA_REGULAR_ATTRIBUTE, DUPLICATE_ATTRIBUTE, 'Duplicate attribute')
	}

	@Test
	def void testDuplicateEnumLiteral() {
		val model = '''
			enum Foo {
				BAR, BAZ, BAR
			}
		'''.parseRosetta
		model.assertError(ROSETTA_ENUM_VALUE, DUPLICATE_ENUM_VALUE, 'Duplicate enum value')
	}
	
	@Test 
	def void testDuplicateType() {
		val model = '''
			class Bar {
			}
			
			class Foo {
			}
			
			enum Foo {
				BAR
			}
		'''.parseRosetta
		model.assertError(ROSETTA_TYPE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
	
	@Test
	def void testDuplicateDataRule_ClassName() {
		val model = '''
			class Foo {
			}
			
			data rule Foo
				when Foo exists
				then Foo must exist
		'''.parseRosetta
		model.assertError(ROSETTA_DATA_RULE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
	
	@Test
	def void testDuplicateDataRule_EnumName() {
		val model = '''
			class Foo {
			}
			
			enum Bar {
				Entry
			}
			
			data rule Bar
				when Foo exists
				then Foo must exist
		'''.parseRosetta
		model.assertError(ROSETTA_DATA_RULE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
	
	@Test
	def void testDuplicateWorkflowRule_ClassName() {
		val model = '''
			class Foo {
			}
			
			class Bar {
			}
			
			workflow rule Foo
				Foo must precede Bar
		'''.parseRosetta
		model.assertError(ROSETTA_WORKFLOW_RULE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
	
	@Test
	def void testDuplicateWorkflowRule_EnumName() {
		val model = '''
			enum Foo {
				Entry
			}
			
			class Bar {
			}
			
			class Baz {
			}
			
			workflow rule Foo
				Bar must precede Baz
		'''.parseRosetta
		model.assertError(ROSETTA_WORKFLOW_RULE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
	
	@Test
	def void testDuplicateChoiceRuleAttribute_thisOne() {
		val model = '''
			class Bar {
				attribute1 string (0..1);
				attribute2 string (0..1);
				attribute3 string (0..1);
			}
			
			choice rule Foo
				for Bar required choice between
				attribute1 and attribute1
		'''.parseRosetta
		model.assertError(ROSETTA_CHOICE_RULE, DUPLICATE_CHOICE_RULE_ATTRIBUTE, 'Duplicate attribute')
	}
	
	@Test
	def void testDuplicateChoiceRuleAttribute_thatOne() {
		val model = '''
			class Bar {
				attribute1 string (0..1);
				attribute2 string (0..1);
				attribute3 string (0..1);
			}
			
			choice rule Foo
				for Bar required choice between
				attribute1 and attribute2 and attribute2
		'''.parseRosetta
		model.assertError(ROSETTA_CHOICE_RULE, DUPLICATE_CHOICE_RULE_ATTRIBUTE, 'Duplicate attribute')
	}
	
	@Test
	def void testClassWithChoiceRuleAndOneOfRule() {
		val model = '''
			class Foo one of {
				attribute1 string (0..1);
				attribute2 string (0..1);
				attribute3 string (0..1);
			}
			
			choice rule Foo_choiceRule
				for Foo required choice between
				attribute1 and attribute2
		'''.parseRosetta
		model.assertError(ROSETTA_CHOICE_RULE, CLASS_WITH_CHOICE_RULE_AND_ONE_OF_RULE, 'Class Foo has both choice rule (Foo_choiceRule) and one of rule')
	}
	
	@Test
	def void testMultipleWhenReferenceClassesForDataRule() {
		val model = '''
			data rule QuoteRule <"">
				when Foo exists
				then Bar exists
					
			class Foo{
			}
			
			class Bar{
			}
		'''.parseRosetta
		model.assertWarning(ROSETTA_DATA_RULE, MULIPLE_CLASS_REFERENCES_DEFINED_FOR_DATA_RULE, 'Data rule "QuoteRule" has multiple class references Foo, Bar. Data rules when/then should always start from the same class')
	}
	
 	@Test
	def checkMappingMultipleSetToWithoutWhenCases() {
		val model = '''
			class Quote {
				attr int (1..1);
					[synonym FIX 
							set to 1,
							set to 2]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Only one set to with no when clause allowed.")
	}
	
	@Test
	def checkMappingMultipleSetToOrdering() {
		val model = '''
			class Quote {
				attr int (1..1);
					[synonym FIX 
							set to 1,
							set to 2 when "a.b.c" exists]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to without when case must be ordered last.")
	}
	
	@Test
	def checkMappingSetToTypeCheck() {
		val model = '''
			class Foo {
				value string (1..1);
			}
			
			class Quote {
				attr Foo (1..1);
					[synonym FIX 
							set to "hello"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToEnumTypeCheck() {
		val model = '''
			enum Foo {
				ONE;
			}
			
			enum Bar {
				BAR;
			}
			
			class Quote {
				attr Foo (1..1);
					[synonym FIX 
							set to Bar.BAR]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToWhenTypeCheck() {
		val model = '''
			class Foo {
				stringVal string (1..1);
			}
			
			class Quote {
				attr Foo (1..1);
					[synonym FpML value foo set when "foo.bar" exists]
			}
		'''.parseRosetta
		model.assertNoErrors
	}
 
	@Test
	def checkValidFunctionParameterType() {
		val model = '''
			calculation  Calc {
				where
					someString string: is TestFunction(2) -> slot
			}
			function TestFunction(param string) {
				slot string;
			}
		'''.parseRosetta
		model.assertError(ROSETTA_CALLABLE_WITH_ARGS_CALL, TYPE_ERROR, "Expected type 'string' but was 'int'")
	}
	
	@Test
	def checkArgumentsCount() {
		val model = '''
			calculation  Calc 
			{
				where
					someString string: is TestFunction("foo") -> slot
					someString string: is TestFunction("foo","bar","baz") -> slot
			}
			
			function TestFunction(param string, param string) {
				slot string;
			}
		'''.parseRosetta.eAllContents.filter(RosettaCallableWithArgsCall).toList
		model.get(0).assertError(ROSETTA_CALLABLE_WITH_ARGS_CALL, null, "Invalid number of arguments. Expecting 2 but passed 1.")
		model.get(1).assertError(ROSETTA_CALLABLE_WITH_ARGS_CALL, null, "Invalid number of arguments. Expecting 2 but passed 3.")
	}
	
	@Test
	def checkCollectionTypeCall() {
	val model = '''
			class Test
			{
				num number (1..1);
				foo string (1..*);
				otherAttr Other (1..*);
			}
			class Other
			{
				testAttr Test (1..1); 
			}
			calculation Calc {
				result int : 1
				
				where
					arg: is Other -> testAttr -> otherAttr -> testAttr -> num
			}
		'''.parseRosetta
		model.assertError(ROSETTA_FEATURE_CALL, null, "Can't map from collection of 'Other' to a single value")
	}
	
	@Test
	def checkOperationTypes() {
	val model = '''
			class Clazz {
				test boolean (0..1);
			}
			data rule DataRule
				when 
					Clazz -> test = True 
					or False <> False
					or 1 > 0
					or 1 < 0
					or 1 >= 0
					or 1 <= 0
					or 1 <> 0
					or 1 = 0
				then 1.1 = .0
					and 0.2 <> 0.1
					and 0.2 > 0.1
					and 0.2 < 0.1
					and 0.2 <= 0.1
					and 0.2 >= 0.1
		'''.parseRosetta
		model.assertNoErrors
	}

	@Test
	def checkValidIsProductClassPath() {
		val model = '''
			class Foo
			{
				foo string (1..1);
			}
			class Bar
			{
				bar Foo (0..1);
			}
			isProduct FooBar
				Foo -> foo
				and Bar -> bar -> foo
		'''.parseRosetta
		model.assertError(ROSETTA_PRODUCT, MULIPLE_CLASS_REFERENCES_DEFINED_FOR_ROSETTA_QUALIFIABLE, 
			'isProduct "FooBar" has multiple class references Foo, Bar. isProduct expressions should always start from the same class')
	}
	
	@Test
	def checkValidIsProductClass() {
		val model = '''
			isProduct root Foo;
			
			class Foo
			{
				foo string (1..1);
			}
			class Bar
			{
				bar Foo (0..1);
			}
			isProduct FooBar
				Bar -> bar -> foo
		'''.parseRosetta
		model.assertError(ROSETTA_PRODUCT, MULIPLE_CLASS_REFERENCES_DEFINED_FOR_ROSETTA_QUALIFIABLE, 
			"isProduct expressions should always start from the 'Foo' class. But found 'Bar'.")
	}
	
	@Test
	def void testUpperCaseAlias() {
		val model =
		'''
			class Bar
			{
				bar string (0..1);
			}
			
			alias Foo
				Bar -> bar
				
				
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_ALIAS, INVALID_CASE,
            "Alias name should start with a lower case")
	}
}
