/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.scoping;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.regnosys.rosetta.builtin.RosettaBuiltinsService;
import com.regnosys.rosetta.generator.util.RosettaFunctionExtensions;
import com.regnosys.rosetta.rosetta.ParametrizedRosettaType;
import com.regnosys.rosetta.rosetta.RosettaAttributeReference;
import com.regnosys.rosetta.rosetta.RosettaEnumValueReference;
import com.regnosys.rosetta.rosetta.RosettaEnumeration;
import com.regnosys.rosetta.rosetta.RosettaExternalClass;
import com.regnosys.rosetta.rosetta.RosettaExternalEnum;
import com.regnosys.rosetta.rosetta.RosettaExternalEnumValue;
import com.regnosys.rosetta.rosetta.RosettaExternalRegularAttribute;
import com.regnosys.rosetta.rosetta.RosettaModel;
import com.regnosys.rosetta.rosetta.RosettaTypeAlias;
import com.regnosys.rosetta.rosetta.TypeCall;
import com.regnosys.rosetta.rosetta.expression.ChoiceOperation;
import com.regnosys.rosetta.rosetta.expression.ConstructorKeyValuePair;
import com.regnosys.rosetta.rosetta.expression.InlineFunction;
import com.regnosys.rosetta.rosetta.expression.RosettaConstructorExpression;
import com.regnosys.rosetta.rosetta.expression.RosettaDeepFeatureCall;
import com.regnosys.rosetta.rosetta.expression.RosettaFeatureCall;
import com.regnosys.rosetta.rosetta.expression.RosettaSymbolReference;
import com.regnosys.rosetta.rosetta.expression.SwitchCaseGuard;
import com.regnosys.rosetta.rosetta.expression.WithMetaEntry;
import com.regnosys.rosetta.rosetta.simple.Annotation;
import com.regnosys.rosetta.rosetta.simple.AnnotationDeepPath;
import com.regnosys.rosetta.rosetta.simple.AnnotationPath;
import com.regnosys.rosetta.rosetta.simple.AnnotationRef;
import com.regnosys.rosetta.rosetta.simple.Attribute;
import com.regnosys.rosetta.rosetta.simple.Condition;
import com.regnosys.rosetta.rosetta.simple.Data;
import com.regnosys.rosetta.rosetta.simple.Function;
import com.regnosys.rosetta.rosetta.simple.FunctionDispatch;
import com.regnosys.rosetta.rosetta.simple.Operation;
import com.regnosys.rosetta.rosetta.simple.Segment;
import com.regnosys.rosetta.rosetta.simple.ShortcutDeclaration;
import com.regnosys.rosetta.types.*;
import com.regnosys.rosetta.utils.DeepFeatureCallUtil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import jakarta.inject.Inject;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider;
import org.eclipse.xtext.util.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*;
import static com.regnosys.rosetta.rosetta.expression.ExpressionPackage.Literals.*;
import static com.regnosys.rosetta.rosetta.simple.SimplePackage.Literals.*;

import static com.regnosys.rosetta.types.RMetaAnnotatedType.withNoMeta;

import com.regnosys.rosetta.RosettaEcoreUtil;

/**
 * This class contains a custom scoping description.
 * <p>
 * See <a href="https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping">Xtext docs</a>
 * on how and when to use it.
 */
public class RosettaScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	
	public final static String LIB_NAMESPACE = "com.rosetta.model";
	
	private final static Logger LOGGER = LoggerFactory.getLogger(RosettaScopeProvider.class);
	
	@Inject 
	private RosettaTypeProvider typeProvider;
	@Inject
	private TypeSystem typeSystem;
	@Inject 
	private ExpectedTypeProvider expectedTypeProvider;
	@Inject
	private RosettaEcoreUtil ecoreUtil;
	@Inject 
	private RosettaFunctionExtensions functionExtensions;
	@Inject
	private DeepFeatureCallUtil deepFeatureCallUtil;
	@Inject
	private RObjectFactory rObjectFactory;
	@Inject 
	private RosettaBuiltinsService builtinsService;
	
	@Override
	public IScope getScope(EObject context, EReference reference) {
		try {
			if (reference.equals(TYPE_CALL_ARGUMENT__PARAMETER)) {
				if (context instanceof TypeCall typeCall) {
					var type = typeCall.getType();
					if (type instanceof ParametrizedRosettaType paramType) {
						return Scopes.scopeFor(paramType.getParameters());
					}
					return IScope.NULLSCOPE;
				}
			} else if (reference.equals(ROSETTA_FEATURE_CALL__FEATURE)) {
				if (context instanceof RosettaFeatureCall featureCall) {
					return createExtendedFeatureScope(featureCall.getReceiver(), typeProvider.getRMetaAnnotatedType(featureCall.getReceiver()));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_DEEP_FEATURE_CALL__FEATURE)) {
				if (context instanceof RosettaDeepFeatureCall deepFeatureCall) {
					return createDeepFeatureScope(typeProvider.getRMetaAnnotatedType(deepFeatureCall.getReceiver()).getRType());
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(CHOICE_OPERATION__ATTRIBUTES)) {
				if (context instanceof ChoiceOperation op) {
					return createExtendedFeatureScope(op.getArgument(), withNoMeta(typeProvider.getRMetaAnnotatedType(op.getArgument()).getRType()));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_ATTRIBUTE_REFERENCE__ATTRIBUTE)) {
				if (context instanceof RosettaAttributeReference attrRef) {
					return createExtendedFeatureScope(attrRef.getReceiver(), withNoMeta(typeProvider.getRTypeOfAttributeReference(attrRef.getReceiver())));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(CONSTRUCTOR_KEY_VALUE_PAIR__KEY)) {
				if (context instanceof ConstructorKeyValuePair) {
					var constructor = (RosettaConstructorExpression) context.eContainer();
					return Scopes.scopeFor(ecoreUtil.allFeatures(typeProvider.getRMetaAnnotatedType(constructor).getRType(), context));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(OPERATION__ASSIGN_ROOT)) {
				if (context instanceof Operation op) {
					List<EObject> outAndAliases = new ArrayList<>();
					var out = functionExtensions.getOutput(op.getFunction());
					if (out != null) {
						outAndAliases.add(out);
					}
					outAndAliases.addAll(op.getFunction().getShortcuts());
					return Scopes.scopeFor(outAndAliases);
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(SEGMENT__FEATURE)) {
				if (context instanceof Operation op) {
					var receiverType = typeProvider.getRTypeOfSymbol(op.getAssignRoot());
					
					// All features accessible from receiver type including meta attributes
					var features = ecoreUtil.allFeatures(receiverType, context, t -> !(t instanceof REnumType));
					
					// We also want to allow the scope provider to return the meta for the type of the attribute (e.g., metadata key)
					if (receiverType.getRType() instanceof RDataType) {
						features = Iterables.concat(features, ecoreUtil.getMetaDescriptions(((RDataType)receiverType.getRType()).getMetaAttributes(), context));
					}
					
					return Scopes.scopeFor(features);
				} else if (context instanceof Segment seg) {
					var prev = seg.getPrev();
					if (prev != null) {
						if (ecoreUtil.isResolved(prev.getFeature())) {
							var receiverType = typeProvider.getRTypeOfFeature(prev.getFeature(), context);
							return Scopes.scopeFor(ecoreUtil.allFeatures(receiverType, context, t -> !(t instanceof REnumType)));
						}
					}
					if (context.eContainer() instanceof Operation) {
						return getScope(context.eContainer(), reference);
					}
					return defaultScope(context, reference);
				}
				return defaultScope(context, reference);
			} else if (reference.equals(ANNOTATION_PATH_ATTRIBUTE_REFERENCE__ATTRIBUTE)) {
				if (context instanceof Attribute attr) {
					var t = typeProvider.getRTypeOfSymbol(attr);
					return Scopes.scopeFor(ecoreUtil.allFeatures(t, context));
				}
			} else if (reference.equals(ANNOTATION_PATH__ATTRIBUTE)) {
				if (context instanceof AnnotationPath ap) {
					var t = typeProvider.getRMetaAnnotatedType(ap.getReceiver());
					return Scopes.scopeFor(ecoreUtil.allFeatures(t, context));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ANNOTATION_DEEP_PATH__ATTRIBUTE)) {
				if (context instanceof AnnotationDeepPath adp) {
					var t = typeProvider.getRMetaAnnotatedType(adp.getReceiver());
					return createDeepFeatureScope(t.getRType());
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_SYMBOL_REFERENCE__SYMBOL)) {
				if (context instanceof Operation op) {
					var function = op.getFunction();
                    List<Attribute> inputsAndOutputs = new ArrayList<>(function.getInputs());
					if(function.getOutput() != null)
						inputsAndOutputs.add(function.getOutput());
					return Scopes.scopeFor(inputsAndOutputs);
				} else {
					var implicitFeatures = typeProvider.findFeaturesOfImplicitVariable(context);

					var expectedMetaType = expectedTypeProvider.getExpectedTypeFromContainer(context);
					var expectedType = expectedMetaType == null ? null : expectedMetaType.getRType();
					if (expectedType instanceof REnumType expectedEnumType) {
						implicitFeatures = Iterables.concat(implicitFeatures, expectedEnumType.getAllEnumValues());
					}
					
					var inline = EcoreUtil2.getContainerOfType(context, InlineFunction.class);
					if (inline != null) {
						var ps = getSymbolParentScope(context, reference);
						return ReversedSimpleScope.scopeFor(
							implicitFeatures,
							ps
						);
					}
					var container = EcoreUtil2.getContainerOfType(context, Function.class);
					if (container != null) {
						var ps = getSymbolParentScope(context, reference);
						return ReversedSimpleScope.scopeFor(
							implicitFeatures,
							ps
						);
					}
					
					var ps = getSymbolParentScope(context, reference);
					return ReversedSimpleScope.scopeFor(
						implicitFeatures,
						ps
					);
				}
			} else if (reference.equals(ROSETTA_ENUM_VALUE_REFERENCE__VALUE)) {
				if (context instanceof RosettaEnumValueReference enumValueRef) {
					return Scopes.scopeFor(rObjectFactory.buildREnumType(enumValueRef.getEnumeration()).getAllEnumValues());
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_EXTERNAL_REGULAR_ATTRIBUTE__ATTRIBUTE_REF)) {
				if (context instanceof RosettaExternalRegularAttribute) {
					var classRef = ((RosettaExternalClass)context.eContainer()).getTypeRef();
					if (classRef instanceof Data data)
						return Scopes.scopeFor(Iterables.filter(Iterables.transform(rObjectFactory.buildRDataType(data).getAllAttributes(), RAttribute::getEObject), Objects::nonNull));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_EXTERNAL_ENUM_VALUE__ENUM_REF)) {
				if (context instanceof RosettaExternalEnumValue) {
					var typeRef = ((RosettaExternalEnum)context.eContainer()).getTypeRef();
					if (typeRef instanceof RosettaEnumeration enumRef)
						return Scopes.scopeFor(rObjectFactory.buildREnumType(enumRef).getAllEnumValues());
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ANNOTATION_REF__ATTRIBUTE)) {
				if (context instanceof AnnotationRef ref) {
					var annoRef = ref.getAnnotation();
					return Scopes.scopeFor(annoRef.getAttributes());
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(FUNCTION_DISPATCH__ATTRIBUTE)) {
				if (context instanceof FunctionDispatch fd) {
					return Scopes.scopeFor(functionExtensions.getInputs(fd));
				}
				return IScope.NULLSCOPE;
			} else if (reference.equals(ROSETTA_EXTERNAL_RULE_SOURCE__SUPER_SOURCES)) {
				return filteredScope(defaultScope(context, reference), it -> it.getEClass().equals(ROSETTA_EXTERNAL_RULE_SOURCE));
			} else if (reference.equals(SWITCH_CASE_GUARD__REFERENCE_GUARD)) {
				if (context instanceof SwitchCaseGuard guard) {
					var argumentType = typeSystem.stripFromTypeAliases(typeProvider.getRMetaAnnotatedType(guard.getCase().getSwitchOperation().getArgument()).getRType());
					if (argumentType instanceof REnumType argEnumType) {
					   return Scopes.scopeFor(argEnumType.getAllEnumValues());
					} else if (argumentType instanceof RChoiceType argChoiceType) {
						return Scopes.scopeFor(Iterables.transform(argChoiceType.getAllOptions(), RChoiceOption::getEObject));
					} else if (argumentType instanceof RDataType) {
                        // TODO: find an efficient way to only include subtypes to improve auto-completion... E.g., by adding supertype info in the resource description?
						// Once done succesfully: remove validation.
                        return filteredScope(defaultScope(context, reference), it -> it.getEClass().equals(DATA));
					} else {
                        return IScope.NULLSCOPE;
                    }
				}
			} else if (reference.equals(WITH_META_ENTRY__KEY)) {
				if (context instanceof WithMetaEntry) {
					var resource = context.eResource();
					if (resource == null || resource.getResourceSet() == null) {
						return IScope.NULLSCOPE;
					}
					
					var metaData = builtinsService.getAnnotationsResource(resource.getResourceSet())
							.getElements().stream().filter(it -> it instanceof Annotation)
							.map(it -> (Annotation)it)
							.filter(it -> "metadata".equals(it.getName()))
							.findAny()
							.orElseThrow();
					return Scopes.scopeFor(metaData.getAttributes());
				}
				return IScope.NULLSCOPE;
			}
			return defaultScope(context, reference);
		}
		catch (Exception e) {
			LOGGER.error ("Error scoping rosetta", e);
			//Any exception that is thrown here is going to have been caused by invalid grammar
			//However invalid grammar is checked as the next step of the process - after scoping
			//so just return an empty scope here and let the validator do its thing afterwards
			return IScope.NULLSCOPE;
		}
	}
	
	@Override
	protected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {
		return List.of(createImportedNamespaceResolver(LIB_NAMESPACE + ".*", ignoreCase));
	}
	
	@Override
	protected List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		if (!(context instanceof RosettaModel model)) {
			return Collections.emptyList();
		}
        List<ImportNormalizer> imports = new ArrayList<>();
		model.getImports().forEach(imp -> {
			var resolver = createImportedNamespaceResolver(imp.getImportedNamespace(), imp.getNamespaceAlias(), ignoreCase);
			if (resolver != null) {
				imports.add(resolver);
			}
		});
		//This import allows two models with the same namespace to reference each other
		imports.add(doCreateImportNormalizer(getQualifiedNameConverter().toQualifiedName(model.getName()), true, ignoreCase));
		return imports;
	}

	protected QualifiedName getQualifiedNameOfLocalElement(final EObject context) {
		if (context instanceof RosettaModel) {
			return null;
		}
		return super.getQualifiedNameOfLocalElement(context);
	}
	
	private ImportNormalizer createImportedNamespaceResolver(String namespace, String namespaceAlias, boolean ignoreCase) {
		if (Strings.isEmpty(namespace)) {
			return null;
		}

		QualifiedName importedNamespace = getQualifiedNameConverter().toQualifiedName(namespace);
		if (importedNamespace == null || importedNamespace.isEmpty()) {
			return null;
		}
		QualifiedName qualifiedAlias = namespaceAlias == null ? null : getQualifiedNameConverter().toQualifiedName(namespaceAlias);

		boolean hasWildCard = ignoreCase ?
				importedNamespace.getLastSegment().equalsIgnoreCase(getWildCard()) :
				importedNamespace.getLastSegment().equals(getWildCard());

		if (hasWildCard) {
			if (importedNamespace.getSegmentCount() <= 1)
				return null;
			return doCreateImportNormalizer(importedNamespace.skipLast(1), qualifiedAlias, true, ignoreCase);
		} else {
			return doCreateImportNormalizer(importedNamespace, qualifiedAlias, false, ignoreCase);
		}
	}

	private ImportNormalizer doCreateImportNormalizer(QualifiedName importedNamespace, QualifiedName namespaceAlias, boolean wildcard, boolean ignoreCase) {
		if (namespaceAlias == null) {
			return doCreateImportNormalizer(importedNamespace, wildcard, ignoreCase);
		}
		return new AliasAwareImportNormalizer(importedNamespace, namespaceAlias, wildcard, ignoreCase);
	}
	
	@Override
	protected ImportNormalizer doCreateImportNormalizer(QualifiedName importedNamespace, boolean wildcard, boolean ignoreCase) {
		return new PatchedImportNormalizer(importedNamespace, wildcard, ignoreCase);
	}

	private IScope defaultScope(EObject object, EReference reference) {
		return super.getScope(object, reference);
	}
	
	@Override
	protected IScope getLocalElementsScope(IScope parent, final EObject context,
										   final EReference reference) {
		IScope localElementsScope = super.getLocalElementsScope(parent, context, reference);
		if (context instanceof RosettaModel model) {
			localElementsScope = Scopes.scopeFor(Iterables.filter(model.getElements(), elem -> reference.getEReferenceType().isSuperTypeOf(elem.eClass()) && !(elem instanceof FunctionDispatch)), localElementsScope);
		}
		return localElementsScope;
	}

	private IScope getSymbolParentScope(EObject object, EReference reference) {
		if (object.eContainer() == null) {
			return filteredScope(defaultScope(object, reference), descr -> !descr.getEClass().equals(ROSETTA_META_TYPE));
		}
		var parentScope = getSymbolParentScope(object.eContainer(), reference);
		if (object instanceof InlineFunction inlFunc) {
			return Scopes.scopeFor(inlFunc.getParameters(), parentScope);
		} else if (object instanceof Function func) {
            List<EObject> features = new ArrayList<>(functionExtensions.getInputs(func));
			var out = functionExtensions.getOutput(func);
			if (out != null)
				features.add(out);
			features.addAll(func.getShortcuts());
			return Scopes.scopeFor(features, parentScope);
		} else if (object instanceof ShortcutDeclaration shortcut) {
			return filteredScope(parentScope, descr -> !descr.getQualifiedName().toString().equals(shortcut.getName())); // TODO use qnames
		} else if (object instanceof RosettaTypeAlias ta) {
			return Scopes.scopeFor(ta.getParameters(), parentScope);
		} else if (object instanceof Condition c) {
			return filteredScope(parentScope, descr -> c.isPostCondition() || descr.getEObjectOrProxy().eContainingFeature() != FUNCTION__OUTPUT);
		}
		return parentScope;
	}
	
	private IScope filteredScope(IScope scope, Predicate<IEObjectDescription> filter) {
		return new FilteringScope(scope, filter);
	}
	
	private IScope createExtendedFeatureScope(EObject receiver, RMetaAnnotatedType metaReceiverType) {
		var receiverType = metaReceiverType.getRType();
		if (receiverType instanceof REnumType && metaReceiverType.getMetaAttributes().isEmpty()) {
			if (!(receiver instanceof RosettaSymbolReference) || !(((RosettaSymbolReference)receiver).getSymbol() instanceof RosettaEnumeration)) {
				return IScope.NULLSCOPE;
			}
		}
		
		return Scopes.scopeFor(ecoreUtil.allFeatures(metaReceiverType, receiver));
	}


	private IScope createDeepFeatureScope(RType receiverType) {
		RType t = receiverType;
		if (receiverType instanceof RChoiceType choice) {
			t = choice.asRDataType();
		}
		if (t instanceof RDataType dt) {
			return Scopes.scopeFor(Iterables.filter(Iterables.transform(deepFeatureCallUtil.findDeepFeatures(dt), RAttribute::getEObject), Objects::nonNull));
		}
		return IScope.NULLSCOPE;
	}
}