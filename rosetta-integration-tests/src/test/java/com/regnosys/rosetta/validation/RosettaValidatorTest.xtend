/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.validation

import com.regnosys.rosetta.tests.RosettaTestInjectorProvider
import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.diagnostics.Diagnostic
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*
import static com.regnosys.rosetta.rosetta.simple.SimplePackage.Literals.*
import static com.regnosys.rosetta.rosetta.expression.ExpressionPackage.Literals.*
import javax.inject.Inject
import com.regnosys.rosetta.tests.util.ExpressionParser

/*
 * Do not write any more tests in here for the following reasons:
 * 1. We are moving away from Xtend to Java for all test and implementation code
 * 2. This approach to putting every test type in one place is messy and hard to navigate, better to split tests concepts into suites
 * 
 * The appropriate test suites can be found by looking for [TestType]ValidatorTest.java where test type could be Expression for example ExpressionValidatorTest
 * 
 */
@Deprecated
@ExtendWith(InjectionExtension)
@InjectWith(RosettaTestInjectorProvider)
class RosettaValidatorTest implements RosettaIssueCodes {

	@Inject extension ValidationTestHelper
	@Inject extension ModelHelper
	@Inject extension ExpressionParser
	
	@Test
	def void testProjectAnnotationHasTargetFormat() {
		val model1 = '''
			func Foo:
				[projection XML]
		'''.parseRosetta
		
		model1.assertNoIssues
		
		val model2 = '''
			func Foo:
				[projection]
		'''.parseRosetta
		
		model2.assertError(ANNOTATION_REF, null, "The `projection` annotation must have a target format such as JSON or XML")		
	}
	
	@Test
	def void testIngestAnnotationHasSourceFormat() {
		val model1 = '''
			func Foo:
				[ingest JSON]
		'''.parseRosetta
		
		model1.assertNoIssues
		
		val model2 = '''
			func Foo:
				[ingest]
		'''.parseRosetta
		
		model2.assertError(ANNOTATION_REF, null, "The `ingest` annotation must have a source format such as JSON or XML")		
	}
	
	@Test
	def void testMultipleTransformAnnotationsCanNotBeUsed() {
		val model1 = '''
			func Foo:
				[ingest JSON]
		'''.parseRosetta
		
		model1.assertNoIssues
		
		val model2 = '''
			func Foo:
				[ingest JSON]
				[enrich]
		'''.parseRosetta
		
		model2.assertError(ANNOTATION_REF, null, "Only one transform annotation allowed.")		
	}
	
	@Test
	def void testTransformAnnotationShouldBeUsedOnFunction() {
		val model1 = '''
			type Foo:
				[ingest JSON]
		'''.parseRosetta
		
		model1.assertError(ROSETTA_NAMED, null, "Transformation annotations only allowed on a function.")

		val model2 = '''
			type Foo:
				[enrich]
		'''.parseRosetta
		
		model2.assertError(ROSETTA_NAMED, null, "Transformation annotations only allowed on a function.")
		
		val model3 = '''
			type Foo:
				[projection]
		'''.parseRosetta
		
		model3.assertError(ROSETTA_NAMED, null, "Transformation annotations only allowed on a function.")
	}
	
	@Test
	def void testConditionShouldBeSingleCardinality() {
		val model = '''
			type Foo:
				condition C:
					[True, False]
		'''.parseRosetta
		
		model.assertWarning(CONDITION, null, "Expecting single cardinality. A condition should be single cardinality")
	}
	
	@Test
	def void testOnlyExistsOnMetaIsNotValidOnSymbolReferences() {
		val model = '''
			type Foo:
			  	a int (0..1)
			  	b int (0..1)
			  	c int (0..1)
			  
			type Bar:
			  	b int (1..1)
			
			func MyFunc:
				inputs:
			    	foosWithMeta Foo (1..*)
			      		[metadata scheme]
			  	output:
			    	result Foo (1..*)
			  	add result:
			    	foosWithMeta filter (b, scheme) only exists
		'''.parseRosetta
				
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
			"Invalid use of `only exists` on meta feature scheme"
		)
	}	
	
	@Test
	def void testOnlyExistsOnMetaIsNotValidOnFeatureCalls() {
		val model = '''
			type Foo:
			  	a int (0..1)
			  	b int (0..1)
			  	c int (0..1)
			  
			type Bar:
			  	b int (1..1)
			
			func MyFunc:
				inputs:
			    	foo Foo (1..1)
			      		[metadata scheme]
			  	output:
			    	result boolean (1..1)
			  	set result:
			    	(foo -> b, foo -> scheme) only exists
		'''.parseRosetta
				
		model.assertError(ROSETTA_FEATURE_CALL, null,
			"Invalid use of `only exists` on meta feature scheme"
		)
	}
	
	@Test
	def void testSwitchDefaultMustComeAtTheEnd() {
 		'''
		42 switch
			default False,
			42 then True
		'''
 			.parseExpression
 			.assertError(SWITCH_CASE_OR_DEFAULT, null, "A default case is only allowed at the end")
	}
	
	@Test
	def void testSwitchOnChoiceCannotHaveLiteralGuard() {
 		val model = '''
			choice Foo:
				Opt1
				Opt2
			
			type Opt1:
			
			type Opt2:
 		'''.parseRosettaWithNoIssues

		'''
		foo switch
			Opt1 then 1,
			"Hello" then 2
		'''
 			.parseExpression(#[model], #["foo Foo (1..1)"])
 			.assertError(SWITCH_CASE_OR_DEFAULT, null, "Case should match a choice option of type Foo")
	}
	
	@Test
	def void testSwitchOnChoiceWithMissingCase() {
 		val model = '''
			choice Foo:
				Opt1
				Bar
			
			choice Bar:
				Opt2
				Opt3
			
			type Opt1:
			
			type Opt2:
			
			type Opt3:
 		'''.parseRosettaWithNoIssues

		'''
		foo switch
			Opt1 then 1,
			Opt2 then 2
		'''
 			.parseExpression(#[model], #["foo Foo (1..1)"])
 			.assertError(SWITCH_OPERATION, null, "Missing the following cases: Opt3. Either provide all or add a default.")
	}
	
	@Test
	def void testSwitchWithNonReachableCase() {
 		val model = '''
			choice Foo:
				Opt1
				Bar
			
			choice Bar:
				Opt2
				Opt3
			
			type Opt1:
			
			type Opt2:
			
			type Opt3:
 		'''.parseRosettaWithNoIssues

		'''
		foo switch
			Opt1 then 1,
			Bar then 2,
			Opt2 then 3
		'''
 			.parseExpression(#[model], #["foo Foo (1..1)"])
 			.assertError(SWITCH_CASE_OR_DEFAULT, null, "Case already covered by Bar")
	}
	
	@Test
 	def void testCanUseMixOfImportAliasAndFullyQualified() {
 		val model1 = '''
 			namespace foo.bar
 			
 			type A:
 				id string (1..1)
 				
 			type D:
 				id string (1..1)
 		'''

 		val model2 = '''
 			namespace test
 			
 			import foo.bar.* as someAlias
 			
 			type B:
 				a someAlias.A (1..1)
 				d foo.bar.D (1..1)
 		'''

 		#[model1, model2].parseRosettaWithNoIssues
 	}	

 	@Test
 	def void testCanUseMixOfImportAliasAndNoAlias() {
 		val model1 = '''
 			namespace foo.bar
 			
 			type A:
 				id string (1..1)
 		'''

 		val model2 = '''
 			namespace test
 			
 			import foo.bar.* as someAlias
 			
 			
 			type D:
 				id string (1..1)
 			
 			type B:
 				a someAlias.A (1..1)
 				d D (1..1)
 		'''

 		#[model1, model2].parseRosettaWithNoIssues
 	}	

 	@Test
 	def void testCanUseImportAliasesWhenWildcardPresent() {
 		val model1 = '''
 			namespace foo.bar
 			
 			type A:
 				id string (1..1)
 		'''

 		val model2 = '''
 			namespace test
 			
 			import foo.bar.* as someAlias
 			
 			
 			
 			type B:
 				a someAlias.A (1..1)
 		'''

 		#[model1, model2].parseRosettaWithNoIssues
 	}

	@Test
 	def void testCannotUseImportAliasesWithoutWildcard() {
 		val model = '''
 			import foo.bar.Test as someAlias
 		'''.parseRosetta

 		model.assertError(IMPORT, null,
 			'"as" statement can only be used with wildcard imports'
 		)
 	}
 	
 	@Test
	def void testSwitchWithDuplicateCase() {
 		'''
		42 switch
			0 then 1,
			1 then 2,
			0 then 3
		'''
 			.parseExpression
 			.assertError(SWITCH_CASE_OR_DEFAULT, null, "Duplicate case")
	}

	@Test
	def void testSwitchInputRecordTypesAreNotValid() {
 		"someDate switch default \"someResult\""
 			.parseExpression(#["someDate date (1..1)"])
 			.assertError(SWITCH_OPERATION, null, "Operator `switch` is not supported for type `date`. Supported argument types are basic types, enumerations, and choice types")	
 	}

	@Test
	def void testSwitchWithMultiCardinalityInputIsInvalid() {
 		val model = '''
 			enum SomeEnum:
 				A
 				B
 				C
 				D
 		'''.parseRosettaWithNoIssues
 		
 		'''
 		inEnum switch 
 			A then "aValue",
 			B then "bValue",
 			C then "cValue",
 			default "someOtherValue"
 		'''
 			.parseExpression(#[model], #["inEnum SomeEnum (1..*)"])
 			.assertWarning(ROSETTA_EXPRESSION, null, "Expecting single cardinality. The `switch` operator requires a single cardinality input")

	}

 	@Test
 	def void testValidSwitchSyntaxEnumIsValidWhenMissingEnumValuesWithDefault() {
 		val model = '''
 			enum SomeEnum:
 				A
 				B
 				C
 				D
 		'''.parseRosettaWithNoIssues
 		
 		'''
 		inEnum switch 
 			A then "aValue",
 			B then "bValue",
 			C then "cValue",
 			default "someOtherValue"
 		'''
 			.parseExpression(#[model], #["inEnum SomeEnum (1..1)"])
			.assertNoIssues
 	}	

 	@Test
 	def void testValidSwitchSyntaxEnumFailsWhenMissingEnumValues() {
 		val model = '''
 			enum SomeEnum:
 				A
 				B
 				C
 				D
 		'''.parseRosettaWithNoIssues

		'''
		inEnum switch 
			A then "aValue",
			B then "bValue",
			C then "cValue"
		'''
			.parseExpression(#[model], #["inEnum SomeEnum (1..1)"])
 			.assertError(SWITCH_OPERATION, null, "Missing the following cases: D. Either provide all or add a default.")
 	}	

	@Test
 	def void testSwitchArgumentMatchesCaseStatementTypes() {
 		val model = '''
 			enum SomeEnum:
 				A
 				B
 				C
 				D
 		'''.parseRosettaWithNoIssues
 		
 		'''
 		inEnum switch 
 			A 	then "aValue",
 			10 	then "bValue",
 			C 	then "cValue",
 			default "defaultValue"
 		'''
 			.parseExpression(#[model], #["inEnum SomeEnum (1..1)"])
 			.assertError(SWITCH_CASE_OR_DEFAULT, null, '''Case should match an enum value of SomeEnum''')
 	}

	@Test
 	def void testDataTypesAreInvalidSwitchInputs() {
 		val model = '''
 			type Foo:
 				fooField string (1..1)
 		'''.parseRosettaWithNoIssues
 		
 		"inFoo switch default 42"
			.parseExpression(#[model], #["inFoo Foo (1..1)"])
 			.assertError(SWITCH_OPERATION, null, "Operator `switch` is not supported for type `Foo`. Supported argument types are basic types, enumerations, and choice types")
 	}

 	@Test
 	def void testValidSwitchSyntaxWithDefault() {
 		val context ='''
			enum SomeEnum:
				A
				B
				C
				D
 		'''.parseRosettaWithNoIssues

 		'''
		inEnum switch 
			A then "aValue",
			B then "bValue",
			C then "cValue",
			default "defaultValue"
 		'''
			.parseExpression(#[context], #["inEnum SomeEnum (1..1)"])
 			.assertNoIssues
 	}

 	@Test
 	def void testValidSwitchSyntaxEnum() {
 		val model = '''
 			enum SomeEnum:
 				A
 				B
 				C
 				D
 		'''.parseRosettaWithNoIssues
 		
 		'''
 		inEnum switch 
 			A then "aValue",
 			B then "bValue",
 			C then "cValue",
 			D then "dValue"
 		'''
 			.parseExpression(#[model], #["inEnum SomeEnum (1..1)"])
 			.assertNoIssues
 	}

 	@Test
 	def void testValidSwitchSyntaxString() {
 		'''
		someInput switch 
			"A" then "aValue",
			"B" then "bValue"
 		'''
 			.parseExpression(#["someInput string (1..1)"])
 			.assertNoIssues
 	}
	
	@Test
	def void testCannotAccessUncommonMetaFeatureOfDeepFeatureCall() {
		val model = '''
		type A:
		    a string (1..1)
		        [metadata scheme]
		
		type B:
		    a string (1..1)
		
		type C:
		    a string (1..1)
		    	[metadata scheme]
		
		choice ABC:
		    A
		    B
		    C
		'''.parseRosettaWithNoIssues
		
		"abc ->> a -> scheme"
			.parseExpression(#[model], #["abc ABC (1..1)"])
			.assertError(ROSETTA_FEATURE_CALL, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to RosettaFeature 'scheme'.")
	}
	
	@Test
	def void testCanAccessMetaFeatureAfterDeepFeatureCall() {
		val context = '''
		choice A:
			B
				[metadata reference]
			C
				[metadata reference]
		
		type B:
			[metadata key]
			id string (1..1)
				[metadata scheme]
		
		type C:
			[metadata key]
			id string (1..1)
				[metadata scheme]
		'''.parseRosettaWithNoIssues
		
		"a ->> id"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertNoIssues
		
		"a ->> id -> scheme"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertNoIssues
	}
	
	@Test
	def void testDeepFeatureCall() {
		val context = '''
		choice A:
			B
			C
		
		type B:
			opt1 Option1 (0..1)
			opt2 Option2 (0..1)
			attr Foo (0..1)
			
			condition Choice: one-of
		
		type C:
			opt1 Option1 (0..1)
			
			condition Choice: one-of
		
		type Option1:
			attr Foo (1..1)
		
		type Option2:
			attr Foo (1..1)
			otherAttr string (1..1)
		
		type Option3:
			attr Foo (1..1)
		
		type Foo:
		'''.parseRosettaWithNoIssues
		
		"a ->> attr"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertNoIssues
		"a ->> opt1"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertNoIssues
		"b ->> attr"
			.parseExpression(#[context], #["b B (1..1)"])
			.assertNoIssues
		
		"a ->> B"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertError(ROSETTA_DEEP_FEATURE_CALL, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to Attribute 'B'.")
		"a ->> opt2"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertError(ROSETTA_DEEP_FEATURE_CALL, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to Attribute 'opt2'.")
		"a ->> otherAttr"
			.parseExpression(#[context], #["a A (1..1)"])
			.assertError(ROSETTA_DEEP_FEATURE_CALL, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to Attribute 'otherAttr'.")
		"b ->> opt1"
			.parseExpression(#[context], #["b B (1..1)"])
			.assertError(ROSETTA_DEEP_FEATURE_CALL, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to Attribute 'opt1'.")
	}
	
	@Test
	def void testCannotCallFuncWithoutInput() {
		val model = '''
		func Foo:
			inputs: a int (1..1)
			output: result int (1..1)
			set result:
				Foo
		'''.parseRosetta
		
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
			"Expected 1 argument, but got 0 instead"
		)
	}
	
	@Test
	def void testOrderDoesNotMatter() {
		val model1 = '''
			namespace test
			
			import a.b.c.*
			
			reporting rule B from string:
				A -> a
			'''
		val model2 = '''
			namespace a.b.c
			
			type Foo:
				a int (1..1)
			
			reporting rule A from string:
				[ Foo { a: 1 }, Foo { a: 2 } ] then last
			'''
		#[model1, model2].parseRosettaWithNoIssues
		#[model2, model1].parseRosettaWithNoIssues
	}
	
	@Test
	def void validConstructor() {
		'''
		type A:
			value int (1..1)
			b string (0..*)
			c A (0..1)
		
		func CreateA:
			output: result A (1..1)
			set result:
				A {
					c: A { value: 0, ... },
					b: ["A", "B"],
					value: 2*21,
				}
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void missingFieldsInConstructor() {
		val model = '''
		type A:
			a int (1..1)
			b string (0..*)
			c A (0..1)
		
		func CreateA:
			output: result A (1..1)
			set result:
				A {
					a: 2*21
				}
		'''.parseRosetta
		
		model.assertError(ROSETTA_CONSTRUCTOR_EXPRESSION, RosettaIssueCodes.MISSING_MANDATORY_CONSTRUCTOR_ARGUMENT,
			"Missing attributes `b`, `c`. Perhaps you forgot a `...` at the end of the constructor?"
		)
	}
	
	@Test
	def void invalidUseOfDotsInConstructor() {
		val model = '''
		type A:
			a int (1..1)
			b string (1..*)
			c A (1..1)
		
		func CreateA:
			output: result A (1..1)
			set result:
				A {
					a: 2*21,
					...
				}
		'''.parseRosetta
		
		model.assertError(ROSETTA_CONSTRUCTOR_EXPRESSION, null,
			"There are no optional attributes left"
		)
	}
	
	@Test
	def void duplicateFieldInConstructor() {
		val model = '''
		type A:
			a int (1..1)
			b string (0..*)
			c A (0..1)
		
		func CreateA:
			output: result A (1..1)
			set result:
				A {
					a: 2*21,
					a: 0,
					...
				}
		'''.parseRosetta
		
		model.assertError(CONSTRUCTOR_KEY_VALUE_PAIR, null,
			"Duplicate attribute `a`"
		)
	}
	
	@Test
	def void wrongTypeInConstructor() {
		val model = '''
		type A:
			a int (1..1)
			b string (0..*)
			c A (0..1)
		
		func CreateA:
			output: result A (1..1)
			set result:
				A {
					a: "abc",
					...
				}
		'''.parseRosetta
		
		model.assertError(CONSTRUCTOR_KEY_VALUE_PAIR, null,
			"Expected type `int`, but got `string` instead. Cannot assign `string` to attribute `a`"
		)
	}
	
	@Test
	def void validRecordConstructor() {
		'''
		func CreateDate:
			output: result date (1..1)
			set result:
				date {
					day: 4,
					month: 11,
					year: 1998
				}
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void missingFieldInRecordConstructor() {
		val model = '''
		func CreateDate:
			output: result date (1..1)
			set result:
				date {
					day: 4
				}
		'''.parseRosetta
		
		model.assertError(ROSETTA_CONSTRUCTOR_EXPRESSION, RosettaIssueCodes.MISSING_MANDATORY_CONSTRUCTOR_ARGUMENT,
			"Missing attributes `month`, `year`"
		)
	}
	
	@Test
	def void invalidUseOfDotsInRecordConstructor() {
		val model = '''
		func CreateDate:
			output: result date (1..1)
			set result:
				date {
					day: 4,
					...
				}
		'''.parseRosetta
		
		model.assertError(ROSETTA_CONSTRUCTOR_EXPRESSION, null,
			"There are no optional attributes left"
		)
	}
	
	@Test
	def void attributeOfImplicitItemWithMultiCardinalityShouldBeMulti() {
		val model = '''
		type A:
			val int (1..1)
		
		func Foo:
			inputs: ins A (0..*)
			output: result int (1..1)
			set result:
				ins then val
		'''.parseRosetta
		
		model.assertWarning(OPERATION, null,
			"Expecting single cardinality. Cannot assign a list to a single value")
	}
	
	@Test
	def void canCallARuleFromARule() {
		'''
		reporting rule Bar from number:
			item
			then Bar2
		
		reporting rule Bar2 from number:
			item + item
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testEligibilityRulesShouldHaveSameInputTypeAsReport() {
		val model = '''
		body Authority TEST_REG
		corpus TEST_REG FOO
		
		report TEST_REG FOO in T+1
		from number
		when Foo
		with type Report
		
		eligibility rule Foo from string:
			item = "42"
		
		reporting rule Bar from number:
			item + item
		
		type Report:
			attr number (1..1)
				[ruleReference Bar]
		'''.parseRosetta
		
		model.assertError(ROSETTA_REPORT, null,
			"Eligibility rule Foo expects a `string` as input, but this report is generated from a `number`.")
	}
	
	@Test
	def void testReportShouldHaveSameInputTypeAsReportType() {
		val model = '''
		body Authority TEST_REG
		corpus TEST_REG FOO
		
		report TEST_REG FOO in T+1
		from number
		when Bla
		with type Report
		
		eligibility rule Bla from number:
			item = 42
		
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from string:
			42
		
		type Report:
			attr1 string (1..1)
				[ruleReference Foo]
			attr2 number (1..1)
				[ruleReference Bar]
		'''.parseRosetta
		
		model.assertError(ROSETTA_REPORT, null,
			"Report type Report expects a `string` as input, but this report is generated from a `number`.")
	}
	
	@Test
	def void testReportShouldHaveSameInputTypeAsRuleSource() {
		val model = '''
		body Authority TEST_REG
		corpus TEST_REG FOO
		
		report TEST_REG FOO in T+1
		from number
		when Bla
		with type Report
		with source RuleSource
		
		eligibility rule Bla from number:
			item = 42
		
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from string:
			42
		
		type Report:
			attr1 string (1..1)
			attr2 number (1..1)
		
		rule source RuleSource {
			Report:
				+ attr1
					[ruleReference Foo]
				+ attr2
					[ruleReference Bar]
		}
		'''.parseRosetta
		
		model.assertError(ROSETTA_REPORT, null,
			"Rule source RuleSource expects a `string` as input, but this report is generated from a `number`.")
	}
	
	@Test
	def void testExternalRuleReferencesMustHaveSameInputType1() {
		val model = '''
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			attr1 string (1..1)
			attr2 number (1..1)
		
		rule source RuleSource {
			Report:
				+ attr1
					[ruleReference Foo]
				+ attr2
					[ruleReference Bar]
		}
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}
	
	@Test
	def void testExternalRuleReferencesMustHaveSameInputType2() {
		val model = '''
		reporting rule Foo1 from string:
			item + item
		
		reporting rule Foo2 from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			sub Subreport (1..1)
			attr number (1..1)
		
		type Subreport:
			attr1 string (1..1)
			attr2 string (1..1)
		
		rule source RuleSource {
			Report:
				+ attr
					[ruleReference Bar]
			Subreport:
				+ attr1
					[ruleReference Foo1]
				+ attr2
					[ruleReference Foo2]
		}
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}
	
	@Test
	def void testExternalRuleReferencesMustHaveSameInputTypeInInheritedReport() {
		val model = '''
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			attr1 string (1..1)
			attr2 number (1..1)
		
		rule source Source1 {
			Report:
				+ attr1
					[ruleReference Foo]
		}
		
		rule source Source2 extends Source1 {
			Report:
				+ attr2
					[ruleReference Bar]
		}
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}
	
	@Test
	def void testRuleReferencesMustHaveSameInputType1() {
		val model = '''
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			attr1 string (1..1)
				[ruleReference Foo]
			attr2 number (1..1)
				[ruleReference Bar]
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}
	
	@Test
	def void testRuleReferencesMustHaveSameInputType2() {
		val model = '''
		reporting rule Foo1 from string:
			item + item
		
		reporting rule Foo2 from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			sub Subreport (1..1)
			attr number (1..1)
				[ruleReference Bar]
		
		type Subreport:
			attr1 string (1..1)
				[ruleReference Foo1]
			attr2 string (1..1)
				[ruleReference Foo2]
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}
	
	@Test
	def void testRuleReferencesMustHaveSameInputType3() {
		val model = '''
		reporting rule Foo1 from string:
			item + item
		
		reporting rule Foo2 from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type Report:
			attr number (1..1)
				[ruleReference Bar]
			sub Subreport (1..1)
		
		type Subreport:
			attr1 string (1..1)
				[ruleReference Foo1]
			attr2 string (1..1)
				[ruleReference Foo2]
		'''.parseRosetta
		
		model.assertError(ATTRIBUTE, null,
			"Rule `Foo1` for sub -> attr1 expects an input of type `string`, while previous rules expect an input of type `number`")
	}
	
	@Test
	def void testRuleReferencesMustHaveSameInputTypeInInheritedReport() {
		val model = '''
		reporting rule Foo from string:
			item + item
		
		reporting rule Bar from number:
			item * 2
		
		type ReportParent:
			attr1 string (1..1)
				[ruleReference Foo]
		
		type ReportChild extends ReportParent:
			attr2 number (1..1)
				[ruleReference Bar]
		'''.parseRosetta
		
		model.assertError(RULE_REFERENCE_ANNOTATION, null,
			"Rule `Bar` expects an input of type `number`, while previous rules expect an input of type `string`")
	}

	@Test
	def void testMandatoryThen1() {
		val model = '''
		type Bar:
			attr Bar (0..*)
			someInt int (1..1)
		
		func Foo:
			inputs:
				input Bar (0..*)
			output:
				result int (0..*)
			
			add result:
				input -> attr only-element -> attr
		            extract [ attr ]
		            flatten
		            filter [ someInt = 42 ]
		            extract [ someInt ]
		'''.parseRosetta
		
        model.assertError(FLATTEN_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
        model.assertError(FILTER_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
        model.assertError(MAP_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
	}
	
	@Test
	def void testMandatoryThen2() {
		val model = '''
		type Bar:
			attr Bar (0..*)
			someInt int (1..1)
			
		func DoTheThing:
			inputs: bar Bar (1..1)
			output: result Bar (0..*)
		
		func Foo:
			inputs:
				input Bar (0..*)
			output:
				result Bar (0..*)
			
			add result:
				input
		            extract [ DoTheThing(item) ] flatten
		            distinct
		            sort [someInt]
		'''.parseRosetta
		
        model.assertError(FLATTEN_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
        model.assertError(DISTINCT_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
        model.assertError(SORT_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
	}
	
	@Test
	def void testMandatoryThen3() {
		val model = '''
		type Bar:
			attr Bar (0..*)
			someInt int (1..1)
		
		func Foo:
			inputs:
				input Bar (0..*)
			output:
				result int (0..*)
			
			add result:
				input -> attr only-element -> attr
		            extract attr
		            then filter [ someInt = 42 ]
		            extract someInt
		'''.parseRosetta
		
        model.assertError(MAP_OPERATION, MANDATORY_THEN,
            "Usage of `then` is mandatory.")
	}

	@Test
	def void testMandatorySquareBrackets() {
		val model = '''
		func Foo:
			inputs:
				input int (0..*)
			output:
				result int (0..*)
			
			add result:
				input
					then extract
						item
							extract item + 1
		'''.parseRosetta
		
		model.assertError(MAP_OPERATION, null,
            "Ambiguous operation. Either use `then` or surround with square brackets to define a nested operation.")
	}
	
	@Test
	def void testSuperfluousSquareBrackets() {
		val model = '''
		func Foo:
			inputs:
				input int (0..*)
			output:
				result int (0..*)
			
			add result:
				input
					then extract [ item + 1 ]
		'''.parseRosetta
		
		model.assertWarning(INLINE_FUNCTION, REDUNDANT_SQUARE_BRACKETS,
            "Usage of brackets is unnecessary.")
	}
	
	@Test
	def void testMandatoryThenSucceeds1() {
		'''
		func Foo:
			inputs:
				input int (0..*)
			output:
				result int (0..*)
			
			add result:
				input
					then extract [
						extract item + 1
					]
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testMandatoryThenSucceeds2() {
		'''
		func Foo:
			inputs:
				input int (0..*)
			output:
				result int (0..*)
			
			add result:
				input
					extract Foo(extract item + 1)
					then flatten
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testMandatoryThenSucceeds3() {
		'''
		func Foo:
			inputs:
				input int (0..*)
			output:
				result int (0..*)
			
			add result:
				input
					extract (
						extract item + 1
					)
		'''.parseRosettaWithNoIssues
	}

	@Test
	def void testParametrizedBasicTypesWithDuplicateParameters() {
		val model = '''
			basicType int(digits int, digits int)
		'''.parseRosetta
		model.assertError(TYPE_PARAMETER, null,
            "Duplicate parameter name `digits`.")
	}

	@Test
	def void noDuplicateInheritanceForRuleSourceTest() {
		val model = '''
			rule source TestA {}
			rule source TestB {}
			rule source TestC extends TestA, TestB {}
		'''.parseRosetta
		model.assertError(ROSETTA_EXTERNAL_RULE_SOURCE, null,
            "A rule source may not extend more than one other rule source.")
	}

	@Test
	def void noDuplicateTypesInAnnotationSourceTest() {
		val model = '''
			type Foo:
				foo string (0..1)
			
			rule source TestA {
				Foo:
				+ foo
				
				Foo:
				+ foo
			}
		'''.parseRosetta
		model.assertWarning(ROSETTA_EXTERNAL_CLASS, null,
            "Duplicate type `Foo`.")
	}

	@Test
	def void synonymNotAllowedInRuleSourceTest() {
		val model = '''
			type Foo:
				foo string (0..1)
			
			rule source TestA {
				Foo:
				[meta "bar"]
				+ foo
					[value "bar" path "baz"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_EXTERNAL_CLASS_SYNONYM, null,
            "You may not define synonyms in a rule source.")
        model.assertError(ROSETTA_EXTERNAL_SYNONYM, null,
            "You may not define synonyms in a rule source.")
	}

	@Test
	def void enumNotAllowedInRuleReferenceSourceTest() {
		val model = '''
			enum Foo:
				BAR
			
			rule source TestA {
				enums
			
				Foo:
				+ BAR
			}
		'''.parseRosetta
		model.assertError(ROSETTA_EXTERNAL_RULE_SOURCE, null,
            "A rule source cannot define annotations for enums.")
	}
	
	@Test
	def void externalRuleSourceCannotExtendExternalSynonymSourceTest() {
		val model = '''
			synonym source SynSource {}
			
			rule source RuleSource extends SynSource {}
		'''.parseRosetta
		model.assertError(ROSETTA_EXTERNAL_RULE_SOURCE, Diagnostic.LINKING_DIAGNOSTIC,
            "Couldn't resolve reference to ExternalAnnotationSource 'SynSource'.")
	}
	
	@Test
	def void cannotRemoveNonExistingRuleReferenceFromExternalRuleSourceTest() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG FOO
			
			report TEST_REG FOO in T+1
			from ReportableEvent
			when FooRule
			with type Foo
			with source TestA
			
			eligibility rule FooRule from Foo:
				filter foo exists
			
			type Foo:
				foo string (0..1)
			
			reporting rule RA from Foo:
				"A"
			
			reporting rule RB from Foo:
				"B"
			
			rule source TestA {
				Foo:
				- foo
			}
		'''.parseRosetta
		model.assertError(ROSETTA_EXTERNAL_REGULAR_ATTRIBUTE, null,
            "There is no rule reference to remove")
	}
	
	@Test
	def void mayNotUseAmbiguousOutputTest() {
		val model = '''
			type Foo:
				result int (1..1)
			
			func F:
			    inputs:
			        foo Foo (1..1)
			    output:
			        result int (1..1)
						
			    set result:
			        foo extract [ result ]
		'''.parseRosetta
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
            "Ambiguous reference. `result` may either refer to `item -> result` or to the output variable.")
	}
	
	@Test
	def void dateMemberHasRightTypeTest() {
		'''
			func F:
				inputs:
					d date (1..1)
				output: result boolean (1..1)
				set result:
					d -> day > 15
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void nameShadowingNotAllowed1() {
		val model =
		'''
			func F:
				inputs:
					a int (1..1)
				output: result int (1..1)
				set result:
					42 extract a [ a ]
		'''.parseRosetta
		model.assertError(CLOSURE_PARAMETER, null,
            "Duplicate name.")
	}
	
	@Test
	def void nameShadowingNotAllowed2() {
		val model =
		'''
			func F:
				output: result int (1..1)
				alias a: 10
				set result:
					42 extract a [ a ]
		'''.parseRosetta
		model.assertError(CLOSURE_PARAMETER, null,
            "Duplicate name.")
	}
	
	@Test
	def void nameShadowingNotAllowed3() {
		val model =
		'''
			func F:
				output: a int (1..1)
				set a:
					42 extract a [ a ]
		'''.parseRosetta
		model.assertError(CLOSURE_PARAMETER, null,
            "Duplicate name.")
	}
	
	@Test
	def void nameShadowingNotAllowed4() {
		val model =
		'''
			func F:
				output: result int (1..1)
				set result:
					42 extract a [ 10 extract a [ a ] ]
		'''.parseRosetta
		model.assertError(CLOSURE_PARAMETER, null,
            "Duplicate name.")
	}
	
	@Test
	def void mayDoRecursiveCalls() {
		'''
			func Rec:
				output: result int (1..1)
				alias test: Rec()
				set result: Rec()
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void testCannotOmitParametersOfBinaryFunction() {
		val model =
		'''
			func Add:
				inputs:
					a int (1..1)
					b int (1..1)
				output: result int (1..1)
				set result:
					a + b
			
			func Foo:
				inputs: a int (0..*)
				output: b int (0..*)
				add b:
					a extract Add
		'''.parseRosetta
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
            "Expected 2 arguments, but got 0 instead")
	}
	
	@Test
	def void testCannotCallParameter() {
		val model =
		'''
			func Foo:
				inputs: a int (0..*)
				output: b int (0..*)
				add b:
					a()
		'''.parseRosetta
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null,
            "A variable may not be called")
	}
	
	@Test
	def void testGeneratedInputWithoutImplicitVariable() {
		val model =
		'''
			func Foo:
				inputs: a int (0..*)
				output: b int (0..*)
				add b:
					extract [item+1]
		'''.parseRosetta
		model.assertError(MAP_OPERATION, null,
            "There is no implicit variable in this context. This operator needs an explicit input in this context.")
	}
	
	@Test
	def void testImplicitVariableWhenItDoesNotExist() {
		val model =
		'''
			func Foo:
				inputs: a int (0..*)
				output: b int (0..*)
				add b:
					item
		'''.parseRosetta
		model.assertError(ROSETTA_IMPLICIT_VARIABLE, null,
            "There is no implicit variable in this context.")
	}
	
	@Test
	def void testGeneratedInputValidationRedirection() {
		val model =
		'''
			type Foo:
				a int (1..1)
				condition A:
					*42
		'''.parseRosetta
		model.assertError(ARITHMETIC_OPERATION, null,
            "Expected type `number`, but got `Foo` instead. Cannot use `Foo` with operator `*`")
	}
		
	@Test
	def void testTypeExpectation() {
		val model =
		'''
			type Foo:
				id int (1..1)
			
				condition R: 
					if id = True
					then id < 1
		'''.parseRosetta
		model.assertError(EQUALITY_OPERATION, null,
			"Types `int` and `boolean` are not comparable")
	}
	
	@Test
	def void testTypeExpectationNoError() {
		val model =
		'''
			type Foo:
				id int (1..1)
			
			condition R:
				if id = 1
				then id < 1
		'''.parseRosettaWithNoErrors
		model.assertNoError(TYPE_ERROR)
	}
	
	@Test
	def void testTypeExpectationError() {
		val model =
		'''
			type Foo:
				id boolean (1..1)
			condition R:
				if id = True
				then id < 1
		'''.parseRosetta
		model.assertError(COMPARISON_OPERATION, null, "Operator `<` is not supported for type `boolean`. Supported types are `number`, `date` and `zonedDateTime`")
	}
	
	@Test
	def void testTypeErrorAssignment_01() {
		val model =
		'''
			namespace "test"
			version "test"
			
			type Foo:
				id boolean (1..1)
			
			func Test:
				inputs: in0 Foo (0..1)
				output: out Foo (0..1)
				set out:
					"not a Foo"
		'''.parseRosetta
		model.assertError(OPERATION, null, "Expected type `Foo`, but got `string` instead. Cannot assign `string` to output `out`")
	}
	
	
	@Test
	def void testTypeErrorAssignment_02() {
		val model =
		'''
			type Foo:
				id boolean (1..1)
			
			func Test:
				inputs: in0 Foo (0..1)
				output: out Foo (0..1)
				set out -> id:
					"not a boolean"
		'''.parseRosetta
		model.assertError(OPERATION, null, "Expected type `boolean`, but got `string` instead. Cannot assign `string` to output `id`")
	}
	
	@Test
	def void testTypeErrorAssignment_03() {
		val model =
		'''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in1 TypeToUse (1..1)
			  output: result TypeToUse (1..1)
			  set result -> attr:
			     in1 as-key
		'''.parseRosetta
		model.assertError(OPERATION, null, "Expected type `WithKey`, but got `TypeToUse` instead. Cannot assign `TypeToUse` to output `attr`")
	}
	
	@Test
	def void testTypeErrorAssignment_04() {
		val model =
		'''
			enum Enumerate : X Y Z

			type Type:
				other Enumerate (0..1)

			func Funcy:
				inputs: in0 Type (0..1)
				output: out string (0..1)
				alias Ali : in0 -> other = Enumerate -> X
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def void testTypeErrorAssignment_05() {
		val model =
		'''
			type Type:
				other int (0..1)

			func Funcy:
				inputs: in0 Type (0..1)
				output: out string (0..1)
				set out: in0->other
		'''.parseRosetta
		model.assertError(OPERATION, null, "Expected type `string`, but got `int` instead. Cannot assign `int` to output `out`")
	}
	
	@Test
	def void testAttributesWithLocationBadTarget() {
		val model = '''
			metaType scheme string
			metaType reference string
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		model.assertError(ROSETTA_DATA_REFERENCE, Diagnostic.LINKING_DIAGNOSTIC, "Couldn't resolve reference to Data 'Foo'.")
	}
	
	@Test
	def void testAttributesWithLocationAndNoAddress() {
		val model ='''
			metaType scheme string
			metaType reference string
			
			type Foo:
				foo string (1..1) 
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		model.assertError(ANNOTATION_QUALIFIER, null, "Target of address must be annotated with metadata location")
	}
	
	@Test
	def void testAttributesWithLocationAndAddressWrongType() {
		val model ='''
			metaType scheme string
			metaType reference string

			type Foo:
				foo int (1..1) 
					[metadata location]
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		model.assertError(ANNOTATION_QUALIFIER, TYPE_ERROR, "Expected address target type of 'string' but was 'int'")
	}
	

	@Test
	def void testDuplicateAttribute() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				i int (1..1)
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def void testDuplicateAttributeNotAllowedWithDiffCard1() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				i int (0..1)
		'''.parseRosetta
		model.assertWarning(ATTRIBUTE, null, "Duplicate attribute 'i'. To override the type, cardinality or annotations of this attribute, use the keyword `override`.")
	}
	
	@Test
	def void testDuplicateAttributeNotAllowedWithDiffCard2() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				i int (1..*)
		'''.parseRosetta
		model.assertWarning(ATTRIBUTE, null, "Duplicate attribute 'i'. To override the type, cardinality or annotations of this attribute, use the keyword `override`.")
	}
	
	@Test
	def void testDuplicateAttributeNotAllowedWithDiffType() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				i string (1..1)
		'''.parseRosetta
		model.assertWarning(ATTRIBUTE, null, "Duplicate attribute 'i'. To override the type, cardinality or annotations of this attribute, use the keyword `override`.")
	}
	
	@Test 
	def void testDuplicateType() {
		val model = '''
			type Bar:
			
			type Foo:
			
			enum Foo: BAR
		'''.parseRosetta
		model.assertError(ROSETTA_TYPE, DUPLICATE_ELEMENT_NAME, 'Duplicate element named \'Foo\'')
	}
		
	@Test
	def void testDuplicateChoiceRuleAttribute_thisOne() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
				condition Foo:
					required choice
					attribute1, attribute1
		'''.parseRosetta
		model.assertError(CHOICE_OPERATION, null, 'Duplicate attribute.')
	}
	
	@Test
	def void testDuplicateChoiceRuleAttribute_thatOne() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
			condition Foo:
				required choice attribute1 , attribute2 , attribute2
		'''.parseRosetta
		model.assertError(CHOICE_OPERATION, null, 'Duplicate attribute.')
	}

	@Test
	def void shouldGenerateNoConditionNameWarning() {
		val model = '''
			type Foo:
				x string (0..1)
				
				condition:
					x exists
		'''.parseRosetta
		model.assertWarning(CONDITION, INVALID_NAME,
			"Condition name should be specified")
	}
	
	@Test
	def void shouldGenerateConditionNameInvalidCaseWarning() {
		val model = '''
			type Foo:
				x string (0..1)
				
				condition xExists:
					x exists
		'''.parseRosetta
		model.assertWarning(CONDITION, INVALID_CASE,
			"Condition name should start with a capital")
	}

	@Test
	def void shouldNoGenerateErrorsForConditionWithInheritedAttributeExists() {
		val model = '''
			type Foo:
				x string (0..1)
			
			type Bar extends Foo:
				y string (0..1)
				
				condition XExists:
					x exists
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}

	@Test
	def checkMergeSynonymErrorOnSingleCardinality() {
		val model = '''
			synonym source FpML
			
			type Foo:
				attr int (0..1)
					[synonym FpML merge "bar"]
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null, "Merge synonym can only be specified on an attribute with multiple cardinality.")
	}
	
	@Test
	def checkMergeSynonymNoErrorOnMultiCardinality() {
		val model = '''
			synonym source FpML
						
			type Foo:
				attr int (0..*)
					[synonym FpML merge "bar"]
		'''.parseRosetta
		model.assertNoErrors()
	}

 	@Test
	def checkMappingMultipleSetToWithoutWhenCases() {
		val model = '''
			type Quote:
				attr int (1..1)
					[synonym FIX 
							set to 1,
							set to 2]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Only one set to with no when clause allowed.")
	}
	
	@Test
	def checkMappingMultipleSetToOrdering() {
		val model = '''
			type Quote:
				attr int (1..1)
					[synonym FIX 
							set to 1,
							set to 2 when "a.b.c" exists]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to without when case must be ordered last.")
	}
	
	@Test
	def checkMappingSetToTypeCheck() {
		val model = '''
			type Foo:
				value0 string (1..1)
			
			type Quote:
				attr Foo (1..1)
					[synonym FIX 
							set to "hello"]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToEnumTypeCheck() {
		val model = '''
			enum Foo: ONE
			

			enum Bar: BAR
			
			type Quote:
				attr Foo (1..1)
					[synonym FIX 
							set to Bar.BAR]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToWhenTypeCheck() {
		val model = '''
			synonym source FpML
			type Foo:
				stringVal string (1..1)
			
			type Quote:
				attr Foo (1..1)
					[synonym FpML value "foo" set when "foo->bar" exists]
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def checkOperationTypes() {
		val model = '''
			type Clazz:
				test boolean (0..1)
			
				condition Condition:
					if test = True 
						or False <> False
						or 1 > 0
						or 1 < 0
						or 1 >= 0
						or 1 <= 0
						or 1 <> 0
						or 1 = 0
					then 1.1 = .0
						and 0.2 <> 0.1
						and 0.2 > 0.1
						and 0.2 < 0.1
						and 0.2 <= 0.1
						and 0.2 >= 0.1
		'''.parseRosetta
		model.assertNoErrors
	}	
	
	@Test
	def checkDateZonedDateTypes() {
		val model = '''
			recordType date{}
			recordType zonedDateTime{}
			
			func Foo:
			  inputs:
			    timestamp zonedDateTime (1..1)
			  output: result date (1..1)
			
			func Bar:
			  inputs:
			    timestamp date (1..1)
			  output: result boolean (1..1)
			  set result:
			     Foo(timestamp) = timestamp
			
		'''.parseRosetta
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null, 
			"Expected type `zonedDateTime`, but got `date` instead. Cannot assign `date` to input `timestamp`")
	}
	
	@Test
	def checkAsKeyUsage_01() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			  output: result TypeToUse (1..1)
			  set result -> attr:
			     in0 as-key
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def checkAsKeyUsage_02() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
				attr2 TypeToUse (0..1)
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			    in1 TypeToUse (1..1)
			  output: result TypeToUse (1..1)
			  set result -> attr2:
			     in1 as-key
		'''.parseRosetta
		model.assertError(AS_KEY_OPERATION, null,
			"'as-key' can only be used with attributes annotated with [metadata reference] annotation.")
	}
	
	@Test
	def checkAsKeyUsage_03() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
				attr2 TypeToUse (0..1)
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			    in1 TypeToUse (1..1)
			  output: result TypeToUse (1..1)
			    [metadata scheme]
			  set result -> scheme:
			     in1 as-key
		'''.parseRosetta
		model.assertError(AS_KEY_OPERATION, null,
			"'as-key' can only be used with attributes annotated with [metadata reference] annotation.")
	}	
	
	@Test
	def checkAsKeyUsage_04() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			  output: result WithKey (1..1)
			  set result:
			     in0 as-key
		'''.parseRosetta
		model.assertError(AS_KEY_OPERATION, null,
			"'as-key' can only be used when assigning an attribute. Example: \"set out -> attribute: value as-key\"")
	}
	
	@Test
	def checkSynonymPathSyntax_01() {
		val model = '''
			type TypeToUse:
				attr string (0..1)
				[synonym FpML value "adjustedDate" path "relative.date" meta id]
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_VALUE_BASE, null,
			"Character '.' is not allowed in paths. Use '->' to separate path segments.")
	}

	@Test
	def checkSynonymPathSyntax_02() {
		val model = '''
			type TypeToUse:
				attr string (0..1)
				[synonym FpML set to "Custom" when "Pty+Src" = "D"]
		'''.parseRosetta
		model.assertError(ROSETTA_MAP_PATH_VALUE, null,
			"Character '+' is not allowed in paths. Use '->' to separate path segments.")
	}

	@Test
	def checkChoiceConditionAttributes() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
				condition:
					required choice
					attribute1
		'''.parseRosetta
		model.assertError(CHOICE_OPERATION, null,
			"At least two attributes must be passed to a choice rule")
	}
	
	
	
	@Test
	def void externalSynonymWithFormatShouldOnlyOnDate() {
	val model='''
			type Foo:
				foo int (0..1)
			
			synonym source TEST_Base
			
			synonym source TEST extends TEST_Base {
				
				Foo:
					+ foo
						[value "bar" path "baz" dateFormat "MM/dd/yy"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format can only be applied to date/time types")
	}
	
	@Test
	def void externalSynonymWithFormatValid() {
	val model='''
			type Foo:
				foo time (0..1)
			
			synonym source TEST_Base
			
			synonym source TEST extends TEST_Base {
				
				Foo:
					+ foo
						[value "bar" path "baz" dateFormat "MMb/dd/yy"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format must be a valid date/time format - Unknown pattern letter: b")
	}
	
	@Test
	def void internalSynonymWithFormatShouldOnlyBeOnDate() {
	val model='''
			type Foo:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" dateFormat "MM/dd/yy"]
			synonym source TEST_Base

		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format can only be applied to date/time types")
	}
	
	@Test
	def void externalSynonymCanExtendMultipleParents() {
	val model='''
			type Foo:
				foo time (0..1)
			
			synonym source TEST_Base1
			synonym source TEST_Base2
			synonym source TEST_Base3
			
			synonym source TEST extends TEST_Base1, TEST_Base2, TEST_Base3 {
			
			}
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def void internalSynonymWithPatternShouldBeValid() {
	val model='''
			type Foo:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" pattern "([A-Z)" "$1"]
			synonym source TEST_Base

		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
"Pattern to match must be a valid regular expression - Unclosed character class near index 5
([A-Z)
     ^")
	}
	
	@Disabled
	@Test
	def void testFishIsAShark() {//This test tests that when a check throws an exception it is translated into a validation error - see ExceptionValidator below
		val model='''
			type MyFish:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" pattern "([A-Z)" "$1"]
			synonym source TEST_Base
			
		'''.parseRosetta
		model.assertError(ROSETTA_TYPE, null,
			"checkForSharks")
	}
	
	@Test
	def void enumSynonymWithPatternShouldBeValid() {
	val model='''
			enum Enumerate : X Y Z
			
			synonym source TEST_Base
			synonym source TEST extends TEST_Base {
				
				enums
				
				Enumerate:
					+ X
						[value "bar" pattern "([A-Z)" "$1"]
			}

		'''.parseRosetta
		model.assertError(ROSETTA_ENUM_SYNONYM, null,
"Pattern to match must be a valid regular expression - Unclosed character class near index 5
([A-Z)
     ^")
	}
	
	@Test
	def shouldGenerateRuleCardinalityWarning() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			from Bar
			when FooRule
			with type BarReport
			
			eligibility rule FooRule from Bar:
				filter bar1 exists
			
			reporting rule Aa from Bar:
				extract bar1 as "A"
			
			type Bar:
				bar1 string (0..*)
			
			type BarReport:
				aa string (1..1)
					[ruleReference Aa]
		'''.parseRosetta
		model.assertWarning(RULE_REFERENCE_ANNOTATION, null, "Expected single cardinality, but rule has multi cardinality")
	}

	@Test
	def shouldGenerateRuleTypeError() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			from Bar
			when FooRule
			with type BarReport
			
			eligibility rule FooRule from Bar:
				filter barA exists
			
			reporting rule Aa from Bar:
				extract barA as "A"

			reporting rule Bb from Bar:
				extract barB as "B"
				
			reporting rule Cc from Bar:
				extract barC as "C"

			reporting rule Dd from Bar:
				extract barD as "D"

			reporting rule Ee from Bar:
				extract barE as "E"
				
			reporting rule Ff from Bar:
				extract barF as "F"
			
			type Bar:
				barA date (0..1)
				barB time (0..1)
				barC zonedDateTime (0..1)
				barD int (0..1)
				barE number (0..1)
				barF BazEnum (0..1)

			enum BazEnum:
				X
				Y
				Z
			
			type BarReport:
				aa string (1..1)
					[ruleReference Aa]
				bb string (1..1)
					[ruleReference Bb]
				cc string (1..1)
					[ruleReference Cc]
				dd string (1..1)
					[ruleReference Dd]
				ee string (1..1)
					[ruleReference Ee]
				ff string (1..1)
					[ruleReference Ff]
			
		'''.parseRosetta
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type date")
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type time")
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type zonedDateTime")
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type int")
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type number")
		model.assertError(RULE_REFERENCE_ANNOTATION, null, "Expected type string, but rule has type BazEnum")
	}
	
	@Test
	def shouldNotGenerateRuleTypeErrorUsingReturn() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			from Bar
			when FooRule
			with type BarReport
			
			eligibility rule FooRule from Bar:
				filter bar1 exists
			
			reporting rule A from Bar:
				"Not Modelled"
					as "A"
			
			type Bar:
				bar1 string (0..1)
			
			type BarReport:
				a string (1..1)
					[ruleReference A]
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorForExtract() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				attr string (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					fooCounts int (0..*)
				
				add fooCounts:
					bars 
						extract bar [ bar -> foos ]
						then extract foosItem [ foosItem count ]
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorDefaultParameterForExtract() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				attr string (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					fooCounts int (0..*)
				
				add fooCounts:
					bars 
						extract item -> foos
						then extract item count
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorForNestedExtract() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result boolean (1..1)
				
				alias results:
					bars -> foos
						extract item -> amount > 0
				
				set result:
					results all = True
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorDefaultParameterForNestedExtract() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result boolean (1..1)
				
				alias results:
					bars -> foos
						extract foo [ foo -> amount > 0 ]
				
				set result:
					results all = True
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}

	@Test
	def shouldNotGenerateErrorForExtractListOperation() {
		val model = '''
			type Bar:
				foo Foo (1..1)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result number (1..1)
				
				set result:
					bars 
						extract item -> foo
						then extract item -> amount
						then distinct 
						then only-element
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldGenerateNoErrorForFeatureCallAfterListOperation() {
		val model = '''
			type Bar:
				foo Foo (1..1)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result number (1..1)
				
				set result:
					bars
						extract item -> foo 
						then distinct only-element -> amount
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	@Disabled
	def shouldGenerateErrorForFeatureCallAfterListOperation2() {
		val model = '''
			type Bar:
				foo Foo (1..1)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result number (1..1)
				
				set result:
					if bars exists
					then bars extract [ item -> foo ] distinct only-element -> amount
		'''.parseRosetta
		// then clause should generate syntax error (see test above shouldGenerateErrorForFeatureCallAfterListOperation)
		model.assertError(ROSETTA_MODEL, Diagnostic.SYNTAX_DIAGNOSTIC, "missing EOF at '->'")
	}

	@Test
	def void shouldNotGenerateCardinalityWarning() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		n1 number (0..1)
			 		n2 number (0..1)
			 		n3 number (0..1)
				output:
					result boolean (0..1)
				
				set result:
					if n1 exists and n2 exists and n3 exists
					then n1 + n2 = n3
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldNotGenerateCardinalityWarning2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		n1 number (0..1)
			 		n2 number (0..1)
			 		n3 number (0..1)
				output:
					result boolean (0..1)
				
				alias n3Alias:
					GetNumberList( n3 ) only-element
				
				set result:
					n1 + n2 = n3Alias
					
			func GetNumberList:
			  [codeImplementation]
				inputs:
					x number (1..1)
				output:
					xs number (0..*)
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateListFilterNoExpressionError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					filteredFoo Foo (0..*)
				
				add filteredFoo:
					foos
						filter
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(FILTER_OPERATION, null, "Missing an expression.")
	}
	
	@Test
	def void shouldGenerateListFilterParametersError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					filteredFoo Foo (0..*)
				
				add filteredFoo:
					foos
						filter a, b [ a -> attr ]
			
			type Foo:
				attr boolean (1..1)
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Function must have 1 named parameter.")
	}
	
	@Test
	def void shouldGenerateListFilterExpressionTypeError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					filteredFoo Foo (0..*)
				
				add filteredFoo:
					foos
						filter [ item -> x ]
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Expression must evaluate to a boolean.")
	}
	
	@Test
	def void shouldGenerateListExtractNoExpressionError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(MAP_OPERATION, null, "Missing an expression.")
	}
	
	@Test
	def void shouldGenerateListExtractParametersError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a, b [ a -> x ]
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Function must have 1 named parameter.")
	}
	
	@Test
	def void extractWithNamedFunctionReferenceShouldGenerateNoError() {
		val model = '''
			func DoSomething:
				inputs:
					a Foo (1..1)
				output:
					result string (1..1)
					
				set result:
					a -> x
			
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract DoSomething
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateListExtractParametersErrorNamedFunctionReference() {
		val model = '''
			func DoSomething:
				inputs:
					a Foo (1..1)
					b boolean (1..1)
				output:
					result string (1..1)
					
				set result:
					a -> x
			
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract DoSomething
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(ROSETTA_SYMBOL_REFERENCE, null, "Expected 2 arguments, but got 0 instead")
	}
	
	@Test
	def void shouldNotGenerateListExtractExpressionCardinalityError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> xs ] // list of lists
						then flatten
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldNotGenerateListExtractExpressionCardinalityError2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> bars ] // list of list<bar>
						then extract bars [ bars -> x ] // list of list<string> (maintain same list cardinality)
						then flatten // list<string>
			
			type Foo:
				bars Bar (0..*)
			
			type Bar:
				x string (0..1)
		'''.parseRosetta
		model.assertNoIssues
	}
	
	@Test
	def void shouldNotGenerateListExtractExpressionCardinalityError3() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> bars ] // list of list<bar>
						then extract bars [ bars -> bazs ] // list of list<baz>
						then extract bazs [ bazs -> x ] // list of list<string>
						then flatten // list<string>
			
			type Foo:
				bars Bar (0..*)
			
			type Bar:
				bazs Baz (0..*)
				
			type Baz:
				x string (0..1)
		'''.parseRosetta
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateListFlattenCardinalityError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> x ] // not a list of lists
						flatten
			
			type Foo:
				x string (0..1) // single cardinality
		'''.parseRosetta
		model.assertError(FLATTEN_OPERATION, null, "List flatten only allowed for list of lists.")
	}
	
	@Test
	def void shouldGenerateListFlattenCardinalityError2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					updatedFoos Foo (0..*)
				
				add updatedFoos:
					foos
						flatten
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertError(FLATTEN_OPERATION, null, "List flatten only allowed for list of lists.")
	}
	
	@Test
	def void shouldNotGenerateListSingleCardinalityError() {
		'''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					s string (1..1)
				
				set s:
					foo
						extract item -> x
			
			type Foo:
				x string (0..1)
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void shouldGenerateListSingleCardinalityError2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					onlyFoo Foo (1..1)
				
				set onlyFoo:
					foo
						only-element
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertWarning(ROSETTA_ONLY_ELEMENT, null, "List only-element operation cannot be used for single cardinality expressions.")
	}
	
	@Test
	def void shouldGenerateListSingleCardinalityError3() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					s string (1..1)
				
				set s:
					foo -> x
						only-element
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertWarning(ROSETTA_ONLY_ELEMENT, null, "List only-element operation cannot be used for single cardinality expressions.")
	}
	
	@Test
	def void shouldNotGenerateListSingleCardinalityError4() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					s string (1..1)
				
				set s:
					foos
						only-element
						extract item -> x
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateListUnflattenedAssignOutputError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> xs ] // list of lists
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertError(OPERATION, null, "Assign expression contains a list of lists, use flatten to create a list")
	}
	
	@Test
	def void shouldGenerateListUnflattenedSetError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				add strings:
					foos
						extract a [ a -> xs ] // list of lists
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertError(OPERATION, null, "Assign expression contains a list of lists, use flatten to create a list")
	}
	
	@Test
	def void shouldGenerateListUnflattenedAliasError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					strings string (0..*)
				
				alias stringsAlias:
					foos
						extract a [ a -> xs ] // list of lists
				
				add strings:
					stringsAlias
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertError(SHORTCUT_DECLARATION, null, "Alias expression contains a list of lists, use flatten to create a list.")
	}
	
	@Test
	def void shouldGenerateListOnlyElementUnflattenedError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					res string (0..1)
				
				set res:
					foos
						extract a [ a -> xs ] // list of lists
						only-element
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertError(ROSETTA_ONLY_ELEMENT, null, "List must be flattened before only-element operation.")
	}
	
	@Test
	def void shouldGenerateListDistinctUnflattenedError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					res string (0..*)
				
				add res:
					foos
						extract a [ a -> xs ] // list of lists
						distinct
			
			type Foo:
				xs string (0..*)
		'''.parseRosetta
		model.assertError(DISTINCT_OPERATION, null, "List must be flattened before distinct operation.")
	}
	
	@Test
	def void shouldNotGenerateTypeErrorForExpressionInBrackets() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					result boolean (1..1)
				
				set result:
					( foo -> x1 and foo -> x2 ) 
					and ( foo -> x4 < 5.0 
						and ( foo -> x3 is absent or foo -> x6 exists ) )
			
			type Foo:
				x1 boolean (1..1)
				x2 boolean (1..1)
				x3 number (0..1)
				x4 number (1..1)
				x5 int (1..1)
				x6 string (0..1)
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateTypeErrorForExpressionInBrackets() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					result boolean (1..1)
				
				set result:
					( foo -> x1 and foo -> x2 ) 
					and ( foo -> x4 // number
						and ( foo -> x3 is absent or foo -> x6 exists ) )
			
			type Foo:
				x1 boolean (1..1)
				x2 boolean (1..1)
				x3 number (0..1)
				x4 number (1..1)
				x5 int (1..1)
				x6 string (0..1)
		'''.parseRosetta
		model.assertError(ROSETTA_BINARY_OPERATION, null, "Expected type `boolean`, but got `number` instead. Cannot use `number` with operator `and`")
	}
	
	@Test
	def void shouldGenerateTypeErrorForExpressionInBrackets3() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (1..1)
				output:
					result boolean (1..1)
				
				set result:
					( foo -> x3 and foo -> x4 ) exists
			
			type Foo:
				x3 number (1..1)
				x4 number (1..1)
		'''.parseRosetta
		model.assertError(LOGICAL_OPERATION, null, "Expected type `boolean`, but got `number` instead. Cannot use `number` with operator `and`")
	}
	
	@Test
	def void shouldGenerateReduceParametersError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					res string (1..1)
				
				set res:
					foos
						reduce a [ a -> x ]
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Function must have 2 named parameters.")
	}
	
	@Test
	def void shouldGenerateReduceTypeError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					res string (1..1)
				
				set res:
					foos
						reduce a, b [ a -> x ]
			
			type Foo:
				x string (0..1)
		'''.parseRosetta
		model.assertError(REDUCE_OPERATION, null, "List reduce expression must evaluate to the same type as the input. Found types Foo and string.")
	}
	
	@Test
	def void shouldGenerateReduceCardinalityError() {
		val model = '''
			type Foo:
				x string (0..1)
			
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					res Foo (1..1)
				
				set res:
					foos
						reduce a, b [ GetFooList( a, b ) ]
			
			func GetFooList:
			 	inputs:
			 		foo1 Foo (1..1)
			 		foo2 Foo (1..1)
				output:
					foos Foo (0..*)
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Operation only supports single cardinality expressions.")
	}
	
	@Test
	def void shouldGenerateListSortCardinalityError() {
		val model = '''
			type Foo:
				attrList string (1..*) // list
			
			func SortFooOnAttr:
				inputs:
					foos Foo (0..*)
				output:
					sortedFoos Foo (0..*)
			
				add sortedFoos:
					foos sort [item -> attrList] // sort based on multi-cardinality
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Operation only supports single cardinality expressions.")
	}
	
	@Test
	def void shouldGenerateListSortTypeError() {
		val model = '''
			type Foo:
				attrList string (1..*) // list
			
			func SortFooOnAttr:
				inputs:
					foos Foo (0..*)
				output:
					sortedFoos Foo (0..*)
			
				add sortedFoos:
					foos sort // sort based on Foo
		'''.parseRosetta
		model.assertError(SORT_OPERATION, null, "Operation sort only supports comparable types (string, int, number, boolean, date). Found type Foo.")
	}
	
	@Test
	def void shouldGenerateListSortTypeError2() {
		val model = '''
			type Bar:
				foo Foo (1..1)
			
			type Foo:
				attr string (1..1)
			
			func SortBarOnFoo:
				inputs:
					bars Bar (0..*)
				output:
					sortedBars Bar (0..*)
			
				add sortedBars:
					bars 
						sort x [ x -> foo ] // sort based on Foo
		'''.parseRosetta
		model.assertError(INLINE_FUNCTION, null, "Operation sort only supports comparable types (string, int, number, boolean, date). Found type Foo.")
	}
	
	@Test
	@Disabled
	def void shouldGenerateListIndexNoItemExpression() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					indexFoo Foo (0..1)
				
				set indexFoo:
					foos
						get-item [ item -> attr ]
			
			type Foo:
				attr int (1..1)
		'''.parseRosetta
		model.assertError(null, null, "List get-item does not allow expressions using an item or named parameter.")
	}
	
	@Test
	@Disabled
	def void shouldGenerateListIndexNoNamedExpression() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
				output:
					indexFoo Foo (0..1)
				
				set indexFoo:
					foos
						get-item x [ x -> attr ]
			
			type Foo:
				attr int (1..1)
		'''.parseRosetta
		model.assertError(null, null, "List get-item does not allow expressions using an item or named parameter.")
	}
	
	@Test
	@Disabled
	def void shouldGenerateListIndexNoItemExpression2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
			 		index int (1..1)
				output:
					indexFoo Foo (0..1)
				
				set indexFoo:
					foos
						get-item [ index ]
			
			type Foo:
				attr int (1..1)
		'''.parseRosetta
		model.assertNoErrors()
	}
	
	@Test
	@Disabled
	def void shouldGenerateListIndexNoItemExpression3() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foos Foo (0..*)
			 		index int (1..1)
				output:
					removeLast Foo (0..1)
				
				set removeLast:
					foos
						remove-index [ foos count - 1 ]
			
			type Foo:
				attr int (1..1)
		'''.parseRosetta
		model.assertNoErrors()
	}
	
	@Test
	def void joinShouldAllowExpressions() {
		'''
			func FuncFoo:
			 	inputs:
			 		stringList string (0..*)
				output:
					joined string (1..1)
				
				set joined:
					stringList
						join ("a" + "b")
			
			type Foo:
				attr int (1..1)
		'''.parseRosettaWithNoIssues
	}
	
	@Test
	def void shouldWarnNonUsedImportsForData() {
		val model = '''

			import foo.bar.*
			
			
			type Foo:
				attr int (1..1)
		'''.parseRosetta
		model.assertWarning(IMPORT, UNUSED_IMPORT, "Unused import foo.bar.*")
	}
	
	
	@Test
	def void shouldNotWarnForValidDataImports() {
		val models = newArrayList('''
			namespace test.one
			
			type Foo:
				attr int (1..1)
		''',
		'''
			namespace test.two
			import test.one.*
			
			
			type Bar:
				attr Foo (1..1)
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
	
	@Test
	def void shouldNotWarnForValidEnumImports() {
		val models = newArrayList('''
			namespace test.one
			
			enum Foo:
				A B C
		''',
		'''
			namespace test.two
			import test.one.*
			
			
			type Bar:
				attr Foo (1..1)
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
	
	@Test
	def void shouldNotWarnForValidFuncImports() {
		val models = newArrayList('''
			namespace test.one
			
			type Foo1:
				attr int (1..1)
		''',
		'''
			namespace test.two
			
			type Foo2:
				attr int (1..1)
		''',
		'''
			namespace test.three
			import test.one.*
			import test.two.*
			
			func Bar:
			  [codeImplementation]
				inputs:
					foo1 Foo1 (1..1)
				output:
					foo2 Foo2 (1..1)
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
	
	@Test
	def void shouldNotWarnForValidFuncAlias() {
		val models = newArrayList('''
			namespace test.one
			
			type Foo1:
				attr int (1..1)
		''',
		'''
			namespace test.two
			import test.one.*
			
			type Foo2:
				attr Foo1 (1..1)
		''',
		'''
			namespace test.three
			import test.one.*
			
			func Bar:
			  [codeImplementation]
				inputs:
					foo1 Foo1 (1..1)
				output:
					foo1x Foo1 (1..1)
				
				alias a: foo1 -> attr
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
	
	@Test
	def void shouldNotWarnForUsedImports() {
		val models = newArrayList('''
			namespace dsl.test
			
			import foo.bar.* 
			
			type A:
			  a qux.MyType (1..1)
		''',
		'''
			namespace foo.bar.qux
			
			
			type MyType:
				a int (0..1)
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
	
	@Test
	def void shouldNotWarnForUsedImportsWithAlias() {
		val models = newArrayList('''
			namespace dsl.test
			
			import foo.bar.* as bar
			
			type A:
			  a bar.qux.MyType (1..1)
		''',
		'''
			namespace foo.bar.qux
			
			
			type MyType:
				a int (0..1)
		''').parseRosetta
		
		models.forEach[assertNoIssues]
	}
}