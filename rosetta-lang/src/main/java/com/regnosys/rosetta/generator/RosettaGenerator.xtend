/*

 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.generator

import com.regnosys.rosetta.generator.external.ExternalGenerators
import com.regnosys.rosetta.generator.java.enums.EnumGenerator
import com.regnosys.rosetta.generator.java.function.FunctionGenerator
import com.regnosys.rosetta.generator.java.object.JavaPackageInfoGenerator
import com.regnosys.rosetta.generator.java.object.MetaFieldGenerator
import com.regnosys.rosetta.generator.java.object.ModelMetaGenerator
import com.regnosys.rosetta.generator.java.object.ModelObjectGenerator
import com.regnosys.rosetta.generator.resourcefsa.ResourceAwareFSAFactory
import com.regnosys.rosetta.rosetta.RosettaModel
import com.rosetta.util.DemandableLock
import java.util.Map
import java.util.concurrent.CancellationException
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import com.regnosys.rosetta.generator.java.reports.RuleGenerator
import com.regnosys.rosetta.generator.java.condition.ConditionGenerator
import com.regnosys.rosetta.generator.java.reports.ReportGenerator
import jakarta.inject.Inject
import com.regnosys.rosetta.config.RosettaGeneratorsConfiguration
import com.regnosys.rosetta.generator.java.expression.DeepPathUtilGenerator
import com.regnosys.rosetta.generator.java.function.LabelProviderGenerator
import java.util.List
import com.regnosys.rosetta.generator.java.JavaClassGenerator
import com.regnosys.rosetta.generator.java.object.validators.CardinalityValidatorGenerator
import com.regnosys.rosetta.generator.java.object.validators.TypeFormatValidatorGenerator
import com.regnosys.rosetta.generator.java.object.validators.OnlyExistsValidatorGenerator

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RosettaGenerator implements IGenerator2 {
	static Logger LOGGER = LoggerFactory.getLogger(RosettaGenerator)

	@Inject EnumGenerator enumGenerator
	@Inject ModelMetaGenerator metaGenerator
	@Inject ConditionGenerator conditionGenerator
	@Inject MetaFieldGenerator metaFieldGenerator
	@Inject ExternalGenerators externalGenerators
	@Inject JavaPackageInfoGenerator javaPackageInfoGenerator
	@Inject RuleGenerator ruleGenerator

	@Inject ModelObjectGenerator dataGenerator
	@Inject CardinalityValidatorGenerator cardinalityValidatorGenerator
	@Inject TypeFormatValidatorGenerator typeFormatValidatorGenerator
	@Inject OnlyExistsValidatorGenerator onlyExistsValidatorGenerator
	@Inject FunctionGenerator funcGenerator
	@Inject ReportGenerator reportGenerator
	@Inject DeepPathUtilGenerator deepPathUtilGenerator
	@Inject LabelProviderGenerator labelProviderGenerator

	@Inject
	ResourceAwareFSAFactory fsaFactory;

	@Inject
	RosettaGeneratorsConfiguration config;

	// For files that are
	val ignoredFiles = #{'model-no-code-gen.rosetta', 'basictypes.rosetta', 'annotations.rosetta'}

	val Map<ResourceSet, DemandableLock> locks = newHashMap

	def void beforeAllGenerate(ResourceSet resourceSet, IFileSystemAccess2 fsa2, IGeneratorContext context) {
		LOGGER.trace("Starting the before all generate method")
		val lock = locks.computeIfAbsent(resourceSet, [new DemandableLock]);
		try {
			lock.getWriteLock(true);
			val models = resourceSet.resources.filter[!ignoredFiles.contains(URI.segments.lastOrNull)].map [
				contents.head as RosettaModel
			].filter[it.shouldGenerate].toList
			val version = models.head?.version // TODO: find a way to access the version of a project directly
			externalGenerators.forEach [ generator |
				generator.beforeAllGenerate(resourceSet, models, version, [ map |
					map.entrySet.forEach[fsa2.generateFile(key, generator.outputConfiguration.getName, value)]
				], lock)
			]
		} catch (CancellationException e) {
			LOGGER.trace("Code generation cancelled, this is expected")
		} catch (Exception e) {
			LOGGER.warn("Unexpected calling before all generate for rosetta -{} - see debug logging for more", e.message)
			LOGGER.debug("Unexpected calling before all generate for rosetta", e);
			throw new GenerationException(e.message, null, null, e.cause)
		} finally {
			lock.releaseWriteLock
		}
	}

	override void beforeGenerate(Resource resource, IFileSystemAccess2 fsa2, IGeneratorContext context) {
		if (!ignoredFiles.contains(resource.URI.segments.lastOrNull)) {
			LOGGER.trace("Starting the before generate method for " + resource.URI.toString)
			val lock = locks.computeIfAbsent(resource.resourceSet, [new DemandableLock]);
			val fsa = fsaFactory.resourceAwareFSA(resource, fsa2, true)
			try {
				lock.getWriteLock(true);

				fsaFactory.beforeGenerate(resource)

				val model = resource.contents.head as RosettaModel
				if (!model.shouldGenerate) {
					return
				}
				val version = model.version

				externalGenerators.forEach [ generator |
					generator.beforeGenerate(resource, model, version, [ map |
						map.entrySet.forEach[fsa.generateFile(key, generator.outputConfiguration.getName, value)]
					], lock)
				]
			} catch (CancellationException e) {
				LOGGER.trace("Code generation cancelled, this is expected")
			} catch (Exception e) {
				LOGGER.warn("Unexpected calling before generate for rosetta -{} - see debug logging for more", e.message)
				LOGGER.debug("Unexpected calling before generate for rosetta", e);
				throw new GenerationException(e.message, resource.URI, null, e.cause)
			} finally {
				lock.releaseWriteLock
			}
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa2, IGeneratorContext context) {
		if (!ignoredFiles.contains(resource.URI.segments.lastOrNull)) {
			LOGGER.trace("Starting the main generate method for " + resource.URI.toString)
			val fsa = fsaFactory.resourceAwareFSA(resource, fsa2, false)
			val lock = locks.computeIfAbsent(resource.resourceSet, [new DemandableLock]);
			try {
				lock.getWriteLock(true);

				val model = resource.contents.head as RosettaModel
				if (!model.shouldGenerate) {
					return
				}
				val version = model.version
				
				val List<JavaClassGenerator<?, ?>> javaGenerators = #[
					conditionGenerator,
					dataGenerator,
					metaGenerator,
					cardinalityValidatorGenerator,
					typeFormatValidatorGenerator,
					onlyExistsValidatorGenerator,
					deepPathUtilGenerator,
					funcGenerator,
					labelProviderGenerator,
					ruleGenerator,
					reportGenerator,
					enumGenerator,
					metaFieldGenerator
				]
				val aggregatedGenerationExceptions =
					javaGenerators.flatMap[generator|
						generator.generateClasses(model, version, fsa2, context.cancelIndicator)
					].toList
				
				if (!aggregatedGenerationExceptions.empty) {
					if (aggregatedGenerationExceptions.size === 1) {
						throw aggregatedGenerationExceptions.get(0)
					}
					throw new AggregateGenerationException("Multiple errors encountered during generation", resource.URI, aggregatedGenerationExceptions)
				}

				// Invoke externally defined code generators
				externalGenerators.forEach [ generator |
					generator.generate(resource, model, version, [ map |
						map.entrySet.forEach[fsa.generateFile(key, generator.outputConfiguration.getName, value)]
					], lock)
				]
			} catch (CancellationException e) {
				LOGGER.trace("Code generation cancelled, this is expected")
			} catch (AggregateGenerationException | GenerationException e) {
				LOGGER.warn(
					"Unexpected calling standard generate for rosetta root element  -{} - see debug logging for more", e.message)
				LOGGER.info("Unexpected calling standard generate for rosetta root element", e);
				throw e
			} catch (Exception e) {
				LOGGER.warn(
					"Unexpected calling standard generate for rosetta -{} - see debug logging for more", e.message)
				LOGGER.info("Unexpected calling standard generate for rosetta", e);
				throw new GenerationException(e.message, resource.URI, null, e.cause)
			} finally {
				LOGGER.trace("ending the main generate method")
				lock.releaseWriteLock
			}
		}
	}

	override void afterGenerate(Resource resource, IFileSystemAccess2 fsa2, IGeneratorContext context) {
		if (!ignoredFiles.contains(resource.URI.segments.lastOrNull)) {
			LOGGER.trace("Starting the after generate method for " + resource.URI.toString)
			val lock = locks.computeIfAbsent(resource.resourceSet, [new DemandableLock]);
			val fsa = fsaFactory.resourceAwareFSA(resource, fsa2, true)
			try {
				lock.getWriteLock(true)

				val model = resource.contents.head as RosettaModel
				if (!model.shouldGenerate) {
					return
				}
				val version = model.version

				externalGenerators.forEach [ generator |
					generator.afterGenerate(resource, model, version, [ map |
						map.entrySet.forEach[fsa.generateFile(key, generator.outputConfiguration.getName, value)]
					], lock)
				]
				fsaFactory.afterGenerate(resource)

				// TODO: move this over to `afterAllGenerate` once the language supports that method as well.
				val models = resource.resourceSet.resources.filter[!ignoredFiles.contains(URI.segments.lastOrNull)].map [
					contents.head as RosettaModel
				].filter[shouldGenerate].toList
				javaPackageInfoGenerator.generatePackageInfoClasses(fsa2, models)
			} catch (CancellationException e) {
				LOGGER.trace("Code generation cancelled, this is expected")
			} catch (Exception e) {
				LOGGER.warn("Unexpected calling after generate for rosetta -{} - see debug logging for more", e.message)
				LOGGER.debug("Unexpected calling after generate for rosetta", e);
				throw new GenerationException(e.message, resource.URI, null, e.cause)
			} finally {
				lock.releaseWriteLock
			}
		}
	}

	def void afterAllGenerate(ResourceSet resourceSet, IFileSystemAccess2 fsa2, IGeneratorContext context) {
		LOGGER.trace("Starting the after all generate method")
		val lock = locks.computeIfAbsent(resourceSet, [new DemandableLock]);
		try {
			lock.getWriteLock(true)

			val models = resourceSet.resources.filter[!ignoredFiles.contains(URI.segments.lastOrNull)].map [
				contents.head as RosettaModel
			].filter[shouldGenerate].toList
			val version = models.head?.version // TODO: find a way to access the version of a project directly
			externalGenerators.forEach [ generator |
				generator.afterAllGenerate(resourceSet, models, version, [ map |
					map.entrySet.forEach[fsa2.generateFile(key, generator.outputConfiguration.getName, value)]
				], lock)
			]
		} catch (CancellationException e) {
			LOGGER.trace("Code generation cancelled, this is expected")
		} catch (Exception e) {
			LOGGER.warn("Unexpected calling after all generate for rosetta -{} - see debug logging for more", e.message)
			LOGGER.debug("Unexpected calling after all generate for rosetta", e);
			throw new GenerationException(e.message, null, null, e.cause)
		} finally {
			lock.releaseWriteLock
		}
	}
	
	private def boolean shouldGenerate(RosettaModel model) {
		config.namespaceFilter.test(model.name) || model.overridden
	}
	
}
