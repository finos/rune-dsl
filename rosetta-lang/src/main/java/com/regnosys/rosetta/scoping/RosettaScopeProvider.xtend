/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.scoping

import com.google.common.base.Predicate
import com.regnosys.rosetta.builtin.RosettaBuiltinsService
import com.regnosys.rosetta.generator.util.RosettaFunctionExtensions
import com.regnosys.rosetta.rosetta.ParametrizedRosettaType
import com.regnosys.rosetta.rosetta.RosettaAttributeReference
import com.regnosys.rosetta.rosetta.RosettaEnumValueReference
import com.regnosys.rosetta.rosetta.RosettaEnumeration
import com.regnosys.rosetta.rosetta.RosettaExternalClass
import com.regnosys.rosetta.rosetta.RosettaExternalEnum
import com.regnosys.rosetta.rosetta.RosettaExternalEnumValue
import com.regnosys.rosetta.rosetta.RosettaExternalRegularAttribute
import com.regnosys.rosetta.rosetta.RosettaModel
import com.regnosys.rosetta.rosetta.RosettaTypeAlias
import com.regnosys.rosetta.rosetta.TypeCall
import com.regnosys.rosetta.rosetta.expression.ChoiceOperation
import com.regnosys.rosetta.rosetta.expression.ConstructorKeyValuePair
import com.regnosys.rosetta.rosetta.expression.InlineFunction
import com.regnosys.rosetta.rosetta.expression.RosettaConstructorExpression
import com.regnosys.rosetta.rosetta.expression.RosettaDeepFeatureCall
import com.regnosys.rosetta.rosetta.expression.RosettaFeatureCall
import com.regnosys.rosetta.rosetta.expression.RosettaSymbolReference
import com.regnosys.rosetta.rosetta.expression.SwitchCaseGuard
import com.regnosys.rosetta.rosetta.expression.WithMetaEntry
import com.regnosys.rosetta.rosetta.simple.Annotation
import com.regnosys.rosetta.rosetta.simple.AnnotationDeepPath
import com.regnosys.rosetta.rosetta.simple.AnnotationPath
import com.regnosys.rosetta.rosetta.simple.AnnotationRef
import com.regnosys.rosetta.rosetta.simple.Attribute
import com.regnosys.rosetta.rosetta.simple.Condition
import com.regnosys.rosetta.rosetta.simple.Data
import com.regnosys.rosetta.rosetta.simple.Function
import com.regnosys.rosetta.rosetta.simple.FunctionDispatch
import com.regnosys.rosetta.rosetta.simple.Operation
import com.regnosys.rosetta.rosetta.simple.Segment
import com.regnosys.rosetta.rosetta.simple.ShortcutDeclaration
import com.regnosys.rosetta.types.ExpectedTypeProvider
import com.regnosys.rosetta.types.RChoiceType
import com.regnosys.rosetta.types.RDataType
import com.regnosys.rosetta.types.REnumType
import com.regnosys.rosetta.types.RMetaAnnotatedType
import com.regnosys.rosetta.types.RObjectFactory
import com.regnosys.rosetta.types.RType
import com.regnosys.rosetta.types.RosettaTypeProvider
import com.regnosys.rosetta.utils.DeepFeatureCallUtil
import java.util.List
import jakarta.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.xtext.scoping.impl.ImportNormalizer
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider
import org.eclipse.xtext.util.Strings
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*
import static com.regnosys.rosetta.rosetta.expression.ExpressionPackage.Literals.*
import static com.regnosys.rosetta.rosetta.simple.SimplePackage.Literals.*

import static extension com.regnosys.rosetta.types.RMetaAnnotatedType.withNoMeta
import com.regnosys.rosetta.RosettaEcoreUtil

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RosettaScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	
	public val static LIB_NAMESPACE = 'com.rosetta.model'
	
	static Logger LOGGER = LoggerFactory.getLogger(RosettaScopeProvider)
	
	@Inject RosettaTypeProvider typeProvider
	@Inject ExpectedTypeProvider expectedTypeProvider
	@Inject extension RosettaEcoreUtil
	@Inject extension RosettaFunctionExtensions
	@Inject extension DeepFeatureCallUtil
	@Inject extension RObjectFactory
	
	@Inject RosettaBuiltinsService rosettaBuiltinsService
	

	override getScope(EObject context, EReference reference) {
		try {
			switch reference {
				case TYPE_CALL_ARGUMENT__PARAMETER: {
					if (context instanceof TypeCall) {
						val type = context.type
						if (type instanceof ParametrizedRosettaType) {
							return Scopes.scopeFor(type.parameters)
						}
						return IScope.NULLSCOPE
					}
				}
				case ROSETTA_FEATURE_CALL__FEATURE: {
					if (context instanceof RosettaFeatureCall) {
						return createExtendedFeatureScope(context.receiver, typeProvider.getRMetaAnnotatedType(context.receiver))
					}
					return IScope.NULLSCOPE
				}
				case ROSETTA_DEEP_FEATURE_CALL__FEATURE: {
					if (context instanceof RosettaDeepFeatureCall) {
						return createDeepFeatureScope(typeProvider.getRMetaAnnotatedType(context.receiver).RType)
					}
					return IScope.NULLSCOPE
				}
				case CHOICE_OPERATION__ATTRIBUTES: {
					if (context instanceof ChoiceOperation) {
						return createExtendedFeatureScope(context.argument, typeProvider.getRMetaAnnotatedType(context.argument).RType.withNoMeta)
					}
					return IScope.NULLSCOPE
				}
				case ROSETTA_ATTRIBUTE_REFERENCE__ATTRIBUTE: {
					if (context instanceof RosettaAttributeReference) {
						return createExtendedFeatureScope(context.receiver, typeProvider.getRTypeOfAttributeReference(context.receiver).withNoMeta)
					}
					return IScope.NULLSCOPE
				}
				case CONSTRUCTOR_KEY_VALUE_PAIR__KEY: {
					if (context instanceof ConstructorKeyValuePair) {
						val constructor = context.eContainer as RosettaConstructorExpression
						return Scopes.scopeFor(typeProvider.getRMetaAnnotatedType(constructor).RType.allFeatures(context))
					}
					return IScope.NULLSCOPE
				}
				case OPERATION__ASSIGN_ROOT: {
					if (context instanceof Operation) {
						val outAndAliases = newArrayList
						val out = getOutput(context.function)
						if (out !== null) {
							outAndAliases.add(out)
						}
						outAndAliases.addAll(context.function.shortcuts)
						return Scopes.scopeFor(outAndAliases)
					}
					return IScope.NULLSCOPE
				}
				case SEGMENT__FEATURE: {
					switch (context) {
						// Case handles the head of the segment
						Operation: {
							val receiverType = typeProvider.getRTypeOfSymbol(context.assignRoot)
							
							// All features accessible from reciever type including meta attributes
							var features = receiverType.allFeatures(context, [t| !(t instanceof REnumType)])
							
							// We also want to allow the scope provider to return the meta for type of the attribute (e.g. metatda key)
							if (receiverType.RType instanceof RDataType) {
								features = features + (receiverType.RType as RDataType).metaAttributes.getMetaDescriptions(context)
							}
							
							return Scopes.scopeFor(features)
						}
						// Case handles the tail of the segment
						Segment: {
							val prev = context.prev
							if (prev !== null) {
								if (prev.feature.isResolved) {
									val receiverType = typeProvider.getRTypeOfFeature(prev.feature, context)
									return Scopes.scopeFor(receiverType.allFeatures(context, [t| !(t instanceof REnumType)]))
								}
							}
							if (context.eContainer instanceof Operation) {
								return getScope(context.eContainer, reference)
							}
							return defaultScope(context, reference)
						}
						default:
							return defaultScope(context, reference)
					}
				}
				case ANNOTATION_PATH_ATTRIBUTE_REFERENCE__ATTRIBUTE: {
					if (context instanceof Attribute) {
						val t = typeProvider.getRTypeOfSymbol(context)
						return Scopes.scopeFor(t.allFeatures(context))
					}
				}
				case ANNOTATION_PATH__ATTRIBUTE: {
					if (context instanceof AnnotationPath) {
						val t = typeProvider.getRMetaAnnotatedType(context.receiver)
						return Scopes.scopeFor(t.allFeatures(context))
					}
					return IScope.NULLSCOPE
				}
				case ANNOTATION_DEEP_PATH__ATTRIBUTE: {
					if (context instanceof AnnotationDeepPath) {
						val t = typeProvider.getRMetaAnnotatedType(context.receiver)
						return createDeepFeatureScope(t.RType)
					}
					return IScope.NULLSCOPE
				}
				case ROSETTA_SYMBOL_REFERENCE__SYMBOL: {
					if (context instanceof Operation) {
						val function = context.function
						val inputsAndOutputs = newArrayList
						if(!function.inputs.nullOrEmpty)
							inputsAndOutputs.addAll(function.inputs)
						if(function.output!==null)
							inputsAndOutputs.add(function.output)
						return Scopes.scopeFor(inputsAndOutputs)
					} else {
						var implicitFeatures = typeProvider.findFeaturesOfImplicitVariable(context)

						val expectedType = expectedTypeProvider.getExpectedTypeFromContainer(context)?.RType
						if (expectedType instanceof REnumType) {
							implicitFeatures = implicitFeatures + expectedType.allEnumValues
						}
						
						val inline = EcoreUtil2.getContainerOfType(context, InlineFunction)
						if(inline !== null) {
							val ps = getSymbolParentScope(context, reference, IScope.NULLSCOPE)
							return ReversedSimpleScope.scopeFor(
								implicitFeatures,
								ps
							)
						}
						val container = EcoreUtil2.getContainerOfType(context, Function)
						if(container !== null) {
							val ps = filteredScope(getSymbolParentScope(context, reference, IScope.NULLSCOPE), [
								descr | descr.EClass !== DATA
							])
							return ReversedSimpleScope.scopeFor(
								implicitFeatures,
								ps
							)
						}
						
						val ps = getSymbolParentScope(context, reference, defaultScope(context, reference))
						return ReversedSimpleScope.scopeFor(
							implicitFeatures,
							ps
						)
					}
				}
				case ROSETTA_ENUM_VALUE_REFERENCE__VALUE: {
					if (context instanceof RosettaEnumValueReference) {
						return Scopes.scopeFor(context.enumeration.buildREnumType.allEnumValues)
					}
					return IScope.NULLSCOPE
				}
				case ROSETTA_EXTERNAL_REGULAR_ATTRIBUTE__ATTRIBUTE_REF: {
					if (context instanceof RosettaExternalRegularAttribute) {
						val classRef = (context.eContainer as RosettaExternalClass).typeRef
						if (classRef instanceof Data)
							return Scopes.scopeFor(classRef.buildRDataType.allAttributes.map[EObject].filter(Attribute))
					}
					return IScope.NULLSCOPE
				}			
				case ROSETTA_EXTERNAL_ENUM_VALUE__ENUM_REF: {
					if (context instanceof RosettaExternalEnumValue) {
						val enumRef = (context.eContainer as RosettaExternalEnum).typeRef
						if (enumRef instanceof RosettaEnumeration)
							return Scopes.scopeFor(enumRef.buildREnumType.allEnumValues)
					}
					return IScope.NULLSCOPE
				}
				case ANNOTATION_REF__ATTRIBUTE: {
					if (context instanceof AnnotationRef) {
						val annoRef = context.annotation
						return Scopes.scopeFor(annoRef.attributes)
					}
					return IScope.NULLSCOPE
				}
				case FUNCTION_DISPATCH__ATTRIBUTE: {
					if (context instanceof FunctionDispatch) {
						return Scopes.scopeFor(getInputs(context))
					}
					return IScope.NULLSCOPE
				}
				case ROSETTA_EXTERNAL_RULE_SOURCE__SUPER_SOURCES: {
					return defaultScope(context, reference).filteredScope[it.EClass == ROSETTA_EXTERNAL_RULE_SOURCE]
				}
				case SWITCH_CASE_GUARD__SYMBOL_GUARD: {
					if (context instanceof SwitchCaseGuard) {
						val argumentType = typeProvider.getRMetaAnnotatedType(context.^case.switchOperation.argument).RType
						if (argumentType instanceof REnumType) {
						   return Scopes.scopeFor(argumentType.allEnumValues)
						} else if (argumentType instanceof RChoiceType) {
							return Scopes.scopeFor(argumentType.allOptions.map[EObject])
						}
					}
					return IScope.NULLSCOPE
				}
				case WITH_META_ENTRY__KEY: {
					if (context instanceof WithMetaEntry) {
						if (context.eResource?.resourceSet === null) {
							return IScope.NULLSCOPE
						}
						
						val metaData = rosettaBuiltinsService.getAnnotationsResource(context.eResource.resourceSet)
							.elements.filter(Annotation).findFirst[name == "metadata"]
						return Scopes.scopeFor(metaData.attributes)
					}
					return IScope.NULLSCOPE
				}
			}
			return defaultScope(context, reference)
		}
		catch (Exception e) {
			LOGGER.error ("Error scoping rosetta", e);
			//Any exception that is thrown here is going to have been caused by invalid grammar
			//However invalid grammar is checked as the next step of the process - after scoping
			//so just return an empty scope here and let the validator do its thing afterwards
			return IScope.NULLSCOPE;
		}
	}
	
	override protected getImplicitImports(boolean ignoreCase) {
		#[createImportedNamespaceResolver(LIB_NAMESPACE + ".*", ignoreCase)]
	}
	
	override protected internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
		return if (context instanceof RosettaModel) {
			val List<ImportNormalizer> imports = newArrayList()
			context.imports.forEach[
				val resolver = createImportedNamespaceResolver(importedNamespace, namespaceAlias, ignoreCase)
				if (resolver !== null) {
					imports.add(resolver)
				}
			]
			//This import allows two models with the same namespace to reference each other
			imports.add(doCreateImportNormalizer(getQualifiedNameConverter.toQualifiedName(context.name), true, ignoreCase))
			return imports
		} else
			emptyList
	}
	
	private def ImportNormalizer createImportedNamespaceResolver(String namespace, String namespaceAlias,
		boolean ignoreCase) {
		if (Strings.isEmpty(namespace)) {
			return null;
		}

		val importedNamespace = qualifiedNameConverter.toQualifiedName(namespace)
		if (importedNamespace === null || importedNamespace.isEmpty()) {
			return null;
		}
		val qualifiedAlias = namespaceAlias === null ? null : qualifiedNameConverter.toQualifiedName(namespaceAlias)

		val hasWildCard = ignoreCase ?
				importedNamespace.getLastSegment().equalsIgnoreCase(getWildCard()) :
				importedNamespace.getLastSegment().equals(getWildCard());

		if (hasWildCard) {
			if (importedNamespace.getSegmentCount() <= 1)
				return null;
			return doCreateImportNormalizer(importedNamespace.skipLast(1), qualifiedAlias, true, ignoreCase);
		} else {
			return doCreateImportNormalizer(importedNamespace, qualifiedAlias, false, ignoreCase);
		}
	}

	private def ImportNormalizer doCreateImportNormalizer(QualifiedName importedNamespace, QualifiedName namespaceAlias,  boolean wildcard, boolean ignoreCase) {
		if (namespaceAlias === null) {
			return doCreateImportNormalizer(importedNamespace, wildcard, ignoreCase);
		}
		return new AliasAwareImportNormalizer(importedNamespace, namespaceAlias, wildcard, ignoreCase);
	}

	private def IScope defaultScope(EObject object, EReference reference) {
		filteredScope(super.getScope(object, reference), [it.EClass !== FUNCTION_DISPATCH])
	}

	private def IScope getSymbolParentScope(EObject object, EReference reference, IScope outer) {
		if (object.eContainer === null) {
			return defaultScope(object, reference)
		}
		val parentScope = getSymbolParentScope(object.eContainer, reference, outer)
		switch (object) {
			InlineFunction: {
				return Scopes.scopeFor(object.parameters, parentScope)
			}
			Function: {
				val features = newArrayList
				features.addAll(getInputs(object))
				val out = getOutput(object)
				if (out !== null)
					features.add(getOutput(object))
				features.addAll(object.shortcuts)
				return Scopes.scopeFor(features, parentScope)
			}
			ShortcutDeclaration: {
				filteredScope(parentScope, [descr|
					descr.qualifiedName.toString != object.name // TODO use qnames
				])
			}
			RosettaTypeAlias: {
				Scopes.scopeFor(object.parameters, parentScope)
			}
			Condition: {
				filteredScope(parentScope, [ descr |
					object.isPostCondition || descr.EObjectOrProxy.eContainingFeature !== FUNCTION__OUTPUT
				])
			}
			RosettaModel:
				filteredScope(defaultScope(object, reference))[ descr |
					#{DATA, ROSETTA_ENUMERATION, FUNCTION, ROSETTA_EXTERNAL_FUNCTION, ROSETTA_RULE}.contains(descr.EClass)
				]
			default:
				parentScope
		}
	}
	
	def private IScope filteredScope(IScope scope, Predicate<IEObjectDescription> filter) {
		new FilteringScope(scope,filter)
	}
	
	private def IScope createExtendedFeatureScope(EObject receiver, RMetaAnnotatedType metaReceiverType) {
		val receiverType = metaReceiverType.RType
		if (receiverType instanceof REnumType) {
			if (!(receiver instanceof RosettaSymbolReference) || !((receiver as RosettaSymbolReference).symbol instanceof RosettaEnumeration)) {
				return IScope.NULLSCOPE
			}
		}
		
		return Scopes.scopeFor(metaReceiverType.allFeatures(receiver))
	}


	private def IScope createDeepFeatureScope(RType receiverType) {
		val t = if (receiverType instanceof RChoiceType) {
			receiverType.asRDataType
		} else {
			receiverType
		}
		if (t instanceof RDataType) {
			return Scopes.scopeFor(t.findDeepFeatures.filter[EObject !== null].map[EObject])
		}
		return IScope.NULLSCOPE
	}
}