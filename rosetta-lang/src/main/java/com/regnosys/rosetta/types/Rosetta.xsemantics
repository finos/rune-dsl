system com.regnosys.rosetta.typing.RosettaTyping extends RosettaTypingAuxiliary

import com.regnosys.rosetta.rosetta.simple.Attribute
import com.regnosys.rosetta.rosetta.simple.Data
import com.regnosys.rosetta.types.RListType
import com.regnosys.rosetta.types.RType
import com.regnosys.rosetta.types.TypeFactory
import com.regnosys.rosetta.utils.ExpressionHelper

import com.regnosys.rosetta.utils.ImplicitVariableUtil
import java.util.Optional
import com.regnosys.rosetta.types.builtin.RBuiltinTypeService
import com.regnosys.rosetta.interpreter.RosettaInterpreter
import com.regnosys.rosetta.interpreter.RosettaInterpreterContext
import com.regnosys.rosetta.types.RAliasType
import com.regnosys.rosetta.utils.RosettaSimpleSystemSolver
import com.regnosys.rosetta.rosetta.RosettaTypeAlias
import com.regnosys.rosetta.types.RTypeFunction
import com.regnosys.rosetta.rosetta.expression.ExpressionFactory
import com.regnosys.rosetta.utils.RosettaSimpleSystemSolver.Equation
import com.regnosys.rosetta.types.RParametrizedType
import com.regnosys.rosetta.rosetta.TypeCall
import com.regnosys.rosetta.rosetta.RosettaMetaType
import com.regnosys.rosetta.rosetta.RosettaBuiltinType
import com.regnosys.rosetta.interpreter.RosettaValue
import com.rosetta.util.DottedPath
import com.regnosys.rosetta.utils.ModelIdProvider
import com.regnosys.rosetta.types.TypeSystem
import com.regnosys.rosetta.types.RObjectFactory
import com.regnosys.rosetta.rosetta.simple.Choice
import com.regnosys.rosetta.rosetta.RosettaEnumeration

inject extension TypeFactory typeFactory
inject extension ExpressionHelper exprHelper
inject extension ImplicitVariableUtil implicitVarUtil
inject extension RBuiltinTypeService builtinTypes
inject extension ModelIdProvider modelIdProvider
inject extension RObjectFactory objectFactory
inject RosettaInterpreter interpreter
inject RosettaSimpleSystemSolver systemSolver
inject TypeSystem typeSystem


auxiliary {
	comparable(RType t1, RType t2)
	listComparable(RListType t1, RListType t2)
	
	// The methods below could be moved to RosettaAuxiliary were it not for issue https://github.com/eclipse/xsemantics/issues/178
	typeFunctionOfTypeAlias(RosettaTypeAlias typeAlias): RTypeFunction cached
	typeCallToRType(TypeCall rt, RosettaInterpreterContext context): RType
	attributeListType(Attribute a): RListType
}

judgments {
	subtype |- RType subtype <: RType supertype
		error subtype + " is not a subtype of " + supertype
	listSubtype |- RListType subtype <| RListType supertype
		error subtype + " is not a list subtype of " + supertype
}

/****** AUXILIARY DEFINITIONS *******/
auxiliary comparable(RType t1, RType t2) {
	empty |- t1 <: t2
	or
	empty |- t2 <: t1
	or
	return false
}
auxiliary listComparable(RListType t1, RListType t2) {
	comparable(t1.itemType, t2.itemType)
	overlap(t1.constraint, t2.constraint)
}

auxiliary typeFunctionOfTypeAlias(RosettaTypeAlias typeAlias) {
	if (typeAlias.name == INT_NAME) {
		return INT_FUNCTION;
	}
	val parameters = typeAlias.parameters;
	val namespace = DottedPath.splitOnDots(typeAlias.model.name)
	val equations = 
			typeAlias.typeCall.arguments.map[arg|
				val ref = ExpressionFactory.eINSTANCE.createRosettaSymbolReference();
				ref.generated = true;
				ref.symbol = arg.parameter;
				return new Equation(ref, arg.value);
			].toList;
	return systemSolver.solve(equations, parameters.toSet).map[solutionSet|
		RTypeFunction.create(namespace, typeAlias.name,
			[arguments|
				typeCallToRType(typeAlias.typeCall, RosettaInterpreterContext.of(arguments))
			],
			[type|
				if (!(type instanceof RParametrizedType)) {
					return Optional.^empty
				}			
				val context = RosettaInterpreterContext.of((type as RParametrizedType).arguments);
				return solutionSet.getSolution(context).map[solution|
					val newArgs = newLinkedHashMap
					parameters.forEach[p| newArgs.put(p.name, solution.get(p))]
					return newArgs;
				]
			]
		)
	].orElseGet[
		RTypeFunction.create(namespace, typeAlias.name,
			[arguments|
				typeCallToRType(typeAlias.typeCall, RosettaInterpreterContext.of(arguments))
			],
			[Optional.^empty]
		)
	]
}

auxiliary typeCallToRType(TypeCall call, RosettaInterpreterContext context) {
	val t = call.type
	
	switch t {
		Choice: t.buildRChoiceType
		Data: t.buildRDataType
		RosettaBuiltinType: {
			val argMap = call.arguments.toMap([parameter.name], [interpreter.interpret(value, context)])
			builtinTypes.getType(t.name, argMap).orElse(null)
		}
		RosettaEnumeration: t.buildREnumType
		RosettaMetaType: {
			val argMap = call.arguments.toMap([parameter.name], [interpreter.interpret(value, context)])
			val builtinResult = builtinTypes.getType(t.name, argMap)
			if (builtinResult.present) {
				builtinResult.get
			} else {
				t.typeCall.typeCallToRType(context)
			}
		}
		RosettaTypeAlias: {
			val args = newLinkedHashMap
			val absentParameters = t.parameters.toSet
			call.arguments.forEach[arg|
				val eval = interpreter.interpret(arg.value, context)
				args.put(arg.parameter.name, eval)
				absentParameters.remove(arg.parameter)
			]
			absentParameters.forEach[
				args.put(name, RosettaValue.^empty)
			]
			val refersTo = t.typeCall.typeCallToRType(RosettaInterpreterContext.of(args))
			new RAliasType(t.typeFunctionOfTypeAlias, args, refersTo)
		}
		default: {
			NOTHING
		}
	}
}

auxiliary attributeListType(Attribute a) {
	return new RListType(typeCallToRType(a.typeCall, new RosettaInterpreterContext), a.card)
}

/*** SUBTYPING **/
rule SAll
	G |- RType t1 <: RType t2
from {
	typeSystem.isSubtypeOf(t1, t2)
}

/*** LIST SUBTYPING ***/
rule SList // SA-List
	G |- RListType s <| RListType t
from {
	G |- s.itemType <: t.itemType
	s.constraint.isSubconstraintOf(t.constraint)
}
