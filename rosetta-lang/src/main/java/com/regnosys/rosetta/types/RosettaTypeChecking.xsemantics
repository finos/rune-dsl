system com.regnosys.rosetta.typing.RosettaTypingChecking extends RosettaTyping

import com.regnosys.rosetta.rosetta.RosettaCardinality
import com.regnosys.rosetta.rosetta.RosettaExternalFunction
import com.regnosys.rosetta.rosetta.expression.ArithmeticOperation
import com.regnosys.rosetta.rosetta.expression.CardinalityModifier
import com.regnosys.rosetta.rosetta.expression.ComparisonOperation
import com.regnosys.rosetta.rosetta.expression.EqualityOperation
import com.regnosys.rosetta.rosetta.expression.ExpressionPackage
import com.regnosys.rosetta.rosetta.expression.ListLiteral
import com.regnosys.rosetta.rosetta.expression.LogicalOperation
import com.regnosys.rosetta.rosetta.expression.ModifiableBinaryOperation
import com.regnosys.rosetta.rosetta.expression.RosettaAbsentExpression
import com.regnosys.rosetta.rosetta.expression.RosettaBinaryOperation
import com.regnosys.rosetta.rosetta.expression.RosettaConditionalExpression
import com.regnosys.rosetta.rosetta.expression.RosettaExistsExpression
import com.regnosys.rosetta.rosetta.expression.RosettaExpression
import com.regnosys.rosetta.rosetta.expression.RosettaOnlyExistsExpression
import com.regnosys.rosetta.rosetta.simple.Function
import com.regnosys.rosetta.types.RDataType
import com.regnosys.rosetta.types.RListType
import com.regnosys.rosetta.types.RType
import com.regnosys.rosetta.types.TypeFactory
import com.regnosys.rosetta.types.TypeValidationUtil
import com.regnosys.rosetta.utils.ExpressionHelper

import com.regnosys.rosetta.rosetta.expression.RosettaSymbolReference
import com.regnosys.rosetta.utils.ImplicitVariableUtil
import org.eclipse.xtext.EcoreUtil2
import com.regnosys.rosetta.rosetta.expression.OneOfOperation
import com.regnosys.rosetta.rosetta.expression.ChoiceOperation
import static com.regnosys.rosetta.rosetta.expression.ExpressionPackage.Literals.*
import com.regnosys.rosetta.types.builtin.RBuiltinTypeService
import com.regnosys.rosetta.interpreter.RosettaInterpreter
import com.regnosys.rosetta.interpreter.RosettaInterpreterContext
import com.regnosys.rosetta.utils.RosettaSimpleSystemSolver
import com.regnosys.rosetta.rosetta.RosettaRule

inject extension TypeFactory typeFactory
inject extension TypeValidationUtil util
inject extension ExpressionHelper exprHelper
inject extension ImplicitVariableUtil implicitVarUtil
inject extension RBuiltinTypeService builtinTypes
inject RosettaInterpreter interpreter
inject RosettaSimpleSystemSolver systemSolver


auxiliary {
	listSubtypeCheck(RosettaExpression sourceObject, RListType expected)
	looseListSubtypeCheck(RosettaExpression sourceObject, RListType expected)
	subtypeCheck(RosettaExpression sourceObject, RType expected)
	comparableListTypeCheck(RosettaBinaryOperation sourceObject)
	comparableTypeCheck(RosettaBinaryOperation sourceObject)
	onlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject)
	looseOnlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject)
	constraintCheck(RosettaExpression sourceObject, RosettaCardinality expected)
	looseConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected)
	notConstraintCheck(RosettaExpression sourceObject, RosettaCardinality notExpected)
	isLooserConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected)
}

/****** TYPE VALIDATION UTILITIES *******/
auxiliary listSubtypeCheck(RosettaExpression sourceObject, RListType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null && !{empty |- actual <| expected}) {
		fail error notAListSubtypeMessage(expected, actual)
			source sourceObject
	}
}
auxiliary looseListSubtypeCheck(RosettaExpression sourceObject, RListType expected) {
    var RListType actual
    empty |- sourceObject : actual or actual = null
    if (expected !== null && actual !== null && !({empty |- actual.itemType <: expected.itemType} && overlap(expected.constraint, actual.constraint))) {
        fail error notAListSubtypeMessage(expected, actual)
            source sourceObject
    }
}
auxiliary subtypeCheck(RosettaExpression sourceObject, RType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null && !{empty |- actual.itemType <: expected}) {
		fail error notASubtypeMessage(expected, actual.itemType)
			source sourceObject
	}
}
auxiliary comparableListTypeCheck(RosettaBinaryOperation sourceObject) {
	var RListType tl
	var RListType tr
	empty |- sourceObject.left : tl or tl = null
	empty |- sourceObject.right : tr or tr = null
	if (tl !== null && tr !== null) {
		tl.listComparable(tr)
		or
		fail error notListComparableMessage(tl, tr)
			source sourceObject
	}
}
auxiliary comparableTypeCheck(RosettaBinaryOperation sourceObject) {
	var RListType tl
	var RListType tr
	empty |- sourceObject.left : tl or tl = null
	empty |- sourceObject.right : tr or tr = null
	if (tl !== null && tr !== null) {
		tl.itemType.comparable(tr.itemType)
		or
		fail error notComparableMessage(tl.itemType, tr.itemType)
			source sourceObject
	}
}
auxiliary onlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject) {
	var RListType tl
    var RListType tr
    empty |- sourceObject.left : tl or tl = null
    empty |- sourceObject.right : tr or tr = null
    if (tl !== null && tr !== null) {
        !tl.constraint.constraintEquals(single) && tr.constraint.constraintEquals(single)
        or
        {
            if (tl.constraint.constraintEquals(single)) {
                if (tr.constraint.constraintEquals(single)) {
                    fail error bothAreSingularMessage(sourceObject)
                        source sourceObject
                        feature ExpressionPackage.Literals.MODIFIABLE_BINARY_OPERATION__CARD_MOD
                } else {
                    fail error notRightIsSingularButLeftIsMessage(tr)
                        source sourceObject.right
                }
            } else {
                fail error notConstraintMessage(single, tr)
                    source sourceObject.right
            }
        }
    }
}
auxiliary looseOnlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject) {
    var RListType tl
    var RListType tr
    empty |- sourceObject.left : tl or tl = null
    empty |- sourceObject.right : tr or tr = null
    if (tl !== null && tr !== null) {
        !tl.constraint.constraintEquals(single) && single.isSubconstraintOf(tr.constraint)
        or
        {
            if (tl.constraint.constraintEquals(single)) {
                if (tr.constraint.constraintEquals(single)) {
                    fail error bothAreSingularMessage(sourceObject)
                        source sourceObject
                        feature ExpressionPackage.Literals.MODIFIABLE_BINARY_OPERATION__CARD_MOD
                } else {
                    fail error notRightIsSingularButLeftIsMessage(tr)
                        source sourceObject.right
                }
            } else {
                fail error notConstraintMessage(single, tr)
                    source sourceObject.right
            }
        }
    }
}
auxiliary constraintCheck(RosettaExpression sourceObject, RosettaCardinality expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.constraintEquals(actual.constraint)
		or
		fail error notConstraintMessage(expected, actual)
			source sourceObject
	}
}
auxiliary looseConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.isSubconstraintOf(actual.constraint)
		or
		fail error notConstraintMessage(expected, actual)
			source sourceObject
	}
}
auxiliary notConstraintCheck(RosettaExpression sourceObject, RosettaCardinality notExpected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (notExpected !== null && actual !== null) {
		!notExpected.constraintEquals(actual.constraint)
		or
		fail error wrongConstraintMessage(notExpected, actual)
			source sourceObject
	}
}
auxiliary isLooserConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.isSubconstraintOf(actual.constraint)
		or
		fail error notLooserConstraintMessage(expected, actual)
			source sourceObject
	}
}

/****** CHECK RULES ********/
checkrule CheckLeftArithmetic for
	ArithmeticOperation op
from {
	if (op.operator == '+') { // TODO: improve error messages
		{
			looseListSubtypeCheck(op.left, singleDate)
		} or {
			looseListSubtypeCheck(op.left, singleUnconstrainedString)
		} or {
			looseListSubtypeCheck(op.left, singleUnconstrainedNumber)
		}
	} else if (op.operator == '-') {
		{
			looseListSubtypeCheck(op.left, singleDate)
		} or {
			looseListSubtypeCheck(op.left, singleUnconstrainedNumber)
		}
	} else {
		looseListSubtypeCheck(op.left, singleUnconstrainedNumber)
	}
}
checkrule CheckRightArithmetic for
	ArithmeticOperation op
from {
	if (op.operator == '+') {
		{
			looseListSubtypeCheck(op.right, singleTime)
		} or {
			looseListSubtypeCheck(op.right, singleUnconstrainedString)
		} or {
			looseListSubtypeCheck(op.right, singleUnconstrainedNumber)
		}
	} else if (op.operator == '-') {
		{
			looseListSubtypeCheck(op.right, singleDate)
		} or {
			looseListSubtypeCheck(op.right, singleUnconstrainedNumber)
		}
	} else {
		looseListSubtypeCheck(op.right, singleUnconstrainedNumber)
	}
}
checkrule CheckAddition for
	ArithmeticOperation op
from {
	var RListType tl
	var RListType tr
	empty |- op.left : tl or tl = null
	empty |- op.right : tr or tr = null
	if (tl !== null && tr !== null) {
		if (op.operator == '+') {
			{
				empty |- tl.itemType <: DATE
				empty |- tr.itemType <: TIME
			}
			or
			{
				empty |- tl.itemType <: UNCONSTRAINED_STRING
				empty |- tr.itemType <: UNCONSTRAINED_STRING
			}
			or
			{
				empty |- tl.itemType <: UNCONSTRAINED_NUMBER
				empty |- tr.itemType <: UNCONSTRAINED_NUMBER
			}
			or 
				fail error "Expected arguments to be either both a `string` or both a `number`, but got `" + relevantItemTypeDescription(tl, tr) + "` and `" + relevantItemTypeDescription(tr, tl) + "` instead."
					source op
		} else if (op.operator == '-') {
			{
				empty |- tl.itemType <: DATE
				empty |- tr.itemType <: DATE
			}
			or
			{
				empty |- tl.itemType <: UNCONSTRAINED_NUMBER
				empty |- tr.itemType <: UNCONSTRAINED_NUMBER
			}
			or 
				fail error "Expected arguments to be either both a `date` or both a `number`, but got `" + tl.itemType.toString() + "` and `" + tr.itemType.toString() + "` instead."
					source op
		}
	}
}

checkrule CheckEqualityOperation for
	EqualityOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) {
		comparableListTypeCheck(op)
	} else {
		looseOnlyRightIsSingularCheck(op)
		comparableTypeCheck(op)
	}
}

checkrule CheckLeftLogical for
	LogicalOperation op
from {
	looseListSubtypeCheck(op.left, singleBoolean)
}
checkrule CheckRightLogical for
	LogicalOperation op
from {
	looseListSubtypeCheck(op.right, singleBoolean)
}

checkrule CheckLeftComparison for
	ComparisonOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) { // TODO: improve error messages
		{
			looseListSubtypeCheck(op.left, singleZonedDateTime)
		} or {
			looseListSubtypeCheck(op.left, singleDate)
		} or {
			looseListSubtypeCheck(op.left, singleUnconstrainedNumber)
		}
	} else {
		{
			subtypeCheck(op.left, ZONED_DATE_TIME)
		} or {
			subtypeCheck(op.left, DATE)
		} or {
			subtypeCheck(op.left, UNCONSTRAINED_NUMBER)
		}
	}
}
checkrule CheckRightComparison for
	ComparisonOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) {
		{
			looseListSubtypeCheck(op.left, singleZonedDateTime)
		} or {
			looseListSubtypeCheck(op.right, singleDate)
		} or {
			looseListSubtypeCheck(op.right, singleUnconstrainedNumber)
		}
	} else {
		{
			subtypeCheck(op.left, ZONED_DATE_TIME)
		} or {
			subtypeCheck(op.right, DATE)
		} or {
			subtypeCheck(op.right, UNCONSTRAINED_NUMBER)
		}
	}
}
checkrule CheckComparison for
	ComparisonOperation op
from {
	var RListType tl
	var RListType tr
	empty |- op.left : tl or tl = null
	empty |- op.right : tr or tr = null
	if (tl !== null && tr !== null) {
		{
			empty |- tl.itemType <: ZONED_DATE_TIME
			empty |- tr.itemType <: ZONED_DATE_TIME
		}
		or
		{
			empty |- tl.itemType <: DATE
			empty |- tr.itemType <: DATE
		}
		or
		{
			empty |- tl.itemType <: UNCONSTRAINED_NUMBER
			empty |- tr.itemType <: UNCONSTRAINED_NUMBER
		}
		or
			fail error "Expected arguments to be either both a `date`, both a `number` or both a `zonedDateTime`, but got `" + tl.itemType.toString() + "` and `" + tr.itemType.toString() + "` instead."
				source op
	}
	if (op.cardMod !== CardinalityModifier.^NONE) {
		looseOnlyRightIsSingularCheck(op)
	}
}

checkrule CheckIfConditionalExpression for
	RosettaConditionalExpression e
from {
	looseListSubtypeCheck(e.^if, singleBoolean)
}
checkrule CheckBodyConditionalExpression for
	RosettaConditionalExpression e
from {
	var RListType tthen
	var RListType telse
	empty |- e.ifthen : tthen or tthen = null
	empty |- e.elsethen : telse or telse = null
	if (tthen !== null && telse !== null) {
		val joined = listJoin(tthen, telse)
		
		if ({empty |- ANY <: joined.itemType}) {
			fail error "Types `" + tthen.itemType.name + "` and `" + telse.itemType.name + "` do not have a common supertype."
		}
	}
}

checkrule CheckListLiteral for
	ListLiteral e
from {
	val telems = newArrayList
	if (e.elements.forall[
		var RListType telem
		empty |- it : telem or telem = null
		if (telem !== null) {
			telems.add(telem)
		}
		telem !== null
	]) {
		telems.fold(emptyNothing, [ RListType acc, RListType telem |
			if (acc === null) {
				null
			} else {
				val sup = join(telem.itemType, acc.itemType);
				if ({empty |- ANY <: sup}) {
					null
				} else {
					createListType(sup, telem.constraint + acc.constraint)
				}
			}
		]) !== null
		or
		fail error "Elements do not have a common supertype: " + telems.join(', ')["`" + it.itemType.name + "`"] + "."
	}
}
 
checkrule CheckRosettaSymbolReference for RosettaSymbolReference e from {
	val f = e.symbol
	switch f {
        RosettaExternalFunction: {
        	{
				f.parameters.size() == e.args.size()
				or
				fail error "Expected " + f.parameters.size() + " argument" + (if (f.parameters.size() === 1) "" else "s") + ", but got " + e.args.size() + " instead."
			}
			(0..<e.args.size).forall[idx |
				val param = f.parameters.get(idx)
				val paramType = if (param.isArray) createListType(typeCallToRType(param.typeCall, new RosettaInterpreterContext), 0) else createListType(typeCallToRType(param.typeCall, new RosettaInterpreterContext), 1, 1)
				looseListSubtypeCheck(e.args.get(idx), paramType)
			]
        }
        Function: {
            {
				f.inputs.size() == e.args.size()
				or
				fail error "Expected " + f.inputs.size() + " argument" + (if (f.inputs.size() === 1) "" else "s") + ", but got " + e.args.size() + " instead."
			}
			(0..<e.args.size).forall[idx |
				looseListSubtypeCheck(e.args.get(idx), f.inputs.get(idx).attributeListType)
			]
        }
        RosettaRule: {
        	{
				1 == e.args.size()
				or
				fail error "Expected 1 argument, but got " + e.args.size() + " instead."
			}
			val paramType = f.input?.typeCallToRType(new RosettaInterpreterContext)?.createListType(single)
			if (paramType !== null) {
				looseListSubtypeCheck(e.args.head, paramType)
			}
        }
    }
}

checkrule CheckExistsExpression for RosettaExistsExpression e from {
	isLooserConstraintCheck(e.argument, createConstraint(0, 1))
}
checkrule CheckAbsentExpression for RosettaAbsentExpression e from {
	isLooserConstraintCheck(e.argument, createConstraint(0, 1))
}
checkrule CheckOnlyExistsExpression for RosettaOnlyExistsExpression e from {
	val first = e.args.head
	val parent = first.parentExpression
	for (var i = 1; i < e.args.size; i++) {
		val other = e.args.get(i)
		for (var j = 0; j < i; j++) {
			if (EcoreUtil2.equals(e.args.get(j), other)) {
				fail error "Duplicate attribute."
					source other
			}
		}
		val otherParent = other.parentExpression
		if ((parent === null) !== (otherParent === null) || parent !== null && otherParent !== null && !EcoreUtil2.equals(parent, otherParent)) {
			if (otherParent !== null) {
				fail error "All parent paths must be equal."
					source otherParent
			} else {
				fail error "All parent paths must be equal."
					source other
			}
		}
	}
	if (parent === null && !e.implicitVariableExistsInContext) {
		fail error "Object must have a parent object."
			source e.args.head
	}
	
	var RListType parentType = null
	if (parent !== null) {
		looseConstraintCheck(parent, single)
		empty |- parent : parentType
	} else {
		parentType = e.typeOfImplicitVariable.orElse(null)
		if (parentType !== null) {
			single.isSubconstraintOf(parentType.constraint)
			or
			fail error notConstraintMessage(single, parentType)
				source e
		}
	}
	if (parentType !== null) {
		val parentData = parentType.itemType as RDataType
		mayBeEmpty(parentData)
		or
		fail error "The `only exists` operator is not applicable to instances of `" + parentData.name + "`."
			source parent
	}
}
checkrule CheckOneOfOperation for OneOfOperation e from {
	looseConstraintCheck(e.argument, single)
	empty |- e.argument : var RListType pt
	if (pt !== null) {
		val itemType = pt.itemType
		if (!(itemType instanceof RDataType)) {
			fail error "The `" + e.operator + "` operator is not applicable to instances of `" + itemType + "`."
				source e.argument
		}
	}
}
checkrule CheckChoiceOperation for ChoiceOperation e from {
	looseConstraintCheck(e.argument, single)
	empty |- e.argument : var RListType pt
	if (pt !== null) {
		val itemType = pt.itemType
		if (!(itemType instanceof RDataType)) {
			fail error "The `" + e.operator + "` operator is not applicable to instances of `" + itemType + "`."
				source e.argument
		}
	}
	if(e.attributes.size < 2) {
		fail error "At least two attributes must be passed to a choice rule."
			feature CHOICE_OPERATION__ATTRIBUTES
	}
}
